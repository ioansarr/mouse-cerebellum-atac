---
title: "Mouse Cerebellum - DA peaks across time in aligned GC pseudotime stages"
author: "Ioannis Sarropoulos"
date: '`r format(Sys.time(), "%d %B, %Y")`'
output: html_document
---

```{r}
suppressPackageStartupMessages({
  library(tidyverse)
  library(data.table)
  library(Seurat)
  library("DESeq2")
  library("rGREAT")
  library(RColorBrewer)
  library(viridis)
  library(ComplexHeatmap)
})
```

```{r}
lineage <- "GC"
```


```{r}
## Mouse peak info
mouse_peaks <- read.table("~/Mouse_Cereb/006_peaks/Mouse_Cerebellum_reproducible_peaks_summary.txt", header = T, sep = "\t", stringsAsFactors = F)

mouse_peaks$min_age_collapsed <- factor(mouse_peaks$min_age_collapsed, levels = c("0-20_muridae", "73-105_eutherian", "160-177_mammalian", "312-350_tetrapod", "435_vertebrate"))

## Pseudotime seurat and bins
atac.seurat <- readRDS(paste0("~/Mouse_Cereb/015_withinLineages/", lineage, "/Mouse_within", lineage, "_lineage_atac_seurat.rds"))

pseudotime_bins <- read_tsv(paste0("~/Mouse_Cereb/015_withinLineages/", lineage, "/Mouse_within", lineage, "_pseudotime_stats.txt"))

pseudotime_bins$timepoint <- factor(pseudotime_bins$timepoint, levels = c("e10", "e11", "e12", "e13", "e15", "e17", "P0", "P04", "P07", "P14", "P63"))
```

UMAP embedding without aligning (raw data)

```{r}
DimPlot(atac.seurat, group.by = "timepoint", pt.size = 0.1) + scale_color_manual(values = brewer.pal(name = "Spectral", n=11)[3:11])
```

UMAP embedding after harmony

```{r}
DimPlot(atac.seurat, group.by = "timepoint", pt.size = 0.1, reduction = "umap_harmony") + scale_color_manual(values = brewer.pal(name = "Spectral", n=11)[3:11])

DimPlot(atac.seurat, group.by = "clusters_harmony", pt.size = 0.1, reduction = "umap_harmony", label = T) 
```

And finally the pseudotime values

```{r}
FeaturePlot(atac.seurat, features = "pseudotime", pt.size = 0.1, reduction = "umap_harmony") + scale_color_viridis()
```

## Step 1: Identifying biologically motivated pseudotime breaks for binning

Now the first important thing is to identify the major phases of differentiation/maturation (i.e. pseudotime intervals).

This makes more sense than simply binning the data in 10/20/50 bins, where the boundaries would be quite arbitrary.

###We have two ways of approximating reasonable boundaries:

#####1. Distribution of pseudotime values across cells

```{r}
hist(atac.seurat$pseudotime, breaks = 100)
abline(v = 0.15, col="red")
abline(v = 0.35, col="red")
abline(v = 0.5, col="red")
abline(v = 0.8, col="red")
```

Based on the distribution of cells, we would argue for four major phases of GC differentiation/migration (still need to put labels on them).

#####2. Mfuzz clusters of CREs and TFs

These are already based on binned data (but with 50 bins). Thus, we can identify the bin where each cluster shifts from active to inactive or the other way around and use its average pseudotime value as break.

We can immediately use the cluster centers for this.

```{r}
## Peak clusters
peaks_clust <- readRDS(paste0("~/Mouse_Cereb/015_withinLineages/", lineage, "/Mouse_within", lineage, "_lineage_peaks_Mfuzz_cluster_object.rds"))
```

```{r}
table(peaks_clust$cluster)

dim(peaks_clust$centers)

plot(peaks_clust$centers[1,])
abline(v=10, col="blue")
abline(v=20, col="blue")
abline(v=28, col="blue")
abline(v=33, col="blue")


plot(peaks_clust$centers[2,])
abline(v=10, col="blue")
abline(v=20, col="blue")
abline(v=28, col="blue")
abline(v=33, col="blue")


plot(peaks_clust$centers[3,])
abline(v=10, col="blue")
abline(v=20, col="blue")
abline(v=28, col="blue")
abline(v=33, col="blue")

plot(peaks_clust$centers[4,])
abline(v=10, col="blue")
abline(v=20, col="blue")
abline(v=28, col="blue")
abline(v=33, col="blue")


plot(peaks_clust$centers[5,])
abline(v=10, col="blue")
abline(v=20, col="blue")
abline(v=28, col="blue")
abline(v=33, col="blue")

plot(peaks_clust$centers[6,])
abline(v=10, col="blue")
abline(v=20, col="blue")
abline(v=28, col="blue")
abline(v=33, col="blue")

plot(peaks_clust$centers[7,])
abline(v=10, col="blue")
abline(v=20, col="blue")
abline(v=28, col="blue")
abline(v=33, col="blue")
```

We see that despite having 7 clusters, we can describe most inflexion points with only 4 breaks (i.e. 5 bins).

Let's see how this compares with the cell histogram

```{r}
hist(atac.seurat$pseudotime, breaks = 100)
abline(v = 0.15, col="red")
abline(v = 0.35, col="red")
abline(v = 0.5, col="red")
abline(v = 0.8, col="red")
abline(v=unique(pseudotime_bins$mean_pseudotime[pseudotime_bins$pseudotime_bin==10]), col="blue")
abline(v=unique(pseudotime_bins$mean_pseudotime[pseudotime_bins$pseudotime_bin==20]), col="blue")
abline(v=unique(pseudotime_bins$mean_pseudotime[pseudotime_bins$pseudotime_bin==28]), col="blue")
abline(v=unique(pseudotime_bins$mean_pseudotime[pseudotime_bins$pseudotime_bin==33]), col="blue")

hist(atac.seurat$pseudotime, breaks = 100)
abline(v=unique(pseudotime_bins$mean_pseudotime[pseudotime_bins$pseudotime_bin==10]), col="blue")
abline(v=unique(pseudotime_bins$mean_pseudotime[pseudotime_bins$pseudotime_bin==20]), col="blue")
abline(v=unique(pseudotime_bins$mean_pseudotime[pseudotime_bins$pseudotime_bin==28]), col="blue")
abline(v=unique(pseudotime_bins$mean_pseudotime[pseudotime_bins$pseudotime_bin==33]), col="blue")

```

The inflexion points overall agree with the breaks suggested by the histogram (ex. large bin between ~0.4= 0.8).

We should go for the inflexion points which give us more resolution to detect splits.

```{r}
unique(pseudotime_bins$mean_pseudotime[pseudotime_bins$pseudotime_bin==10])
unique(pseudotime_bins$mean_pseudotime[pseudotime_bins$pseudotime_bin==20])
unique(pseudotime_bins$mean_pseudotime[pseudotime_bins$pseudotime_bin==28])
unique(pseudotime_bins$mean_pseudotime[pseudotime_bins$pseudotime_bin==33])

VlnPlot(atac.seurat, features = "pseudotime", group.by = "timepoint", pt.size = 0) +scale_fill_manual(values = brewer.pal(name = "Spectral", n=11)[3:11]) +
  geom_hline(yintercept = unique(pseudotime_bins$mean_pseudotime[pseudotime_bins$pseudotime_bin==10])) +
  geom_hline(yintercept = unique(pseudotime_bins$mean_pseudotime[pseudotime_bins$pseudotime_bin==20])) +
geom_hline(yintercept = unique(pseudotime_bins$mean_pseudotime[pseudotime_bins$pseudotime_bin==28])) +
  geom_hline(yintercept = unique(pseudotime_bins$mean_pseudotime[pseudotime_bins$pseudotime_bin==33]))
```

Ok, seems like we have identified major cutoffs.

## Step 2: Binning, making pseudobulks and creating DESeq design matrix

```{r}
pseudotime_bins$pseudotime_bin_broad <- cut(x = pseudotime_bins$pseudotime, breaks = c(0,                                                                                        unique(pseudotime_bins$mean_pseudotime[pseudotime_bins$pseudotime_bin==10]),
                                                                                       unique(pseudotime_bins$mean_pseudotime[pseudotime_bins$pseudotime_bin==20]),
                                                                                      
                                                                                       unique(pseudotime_bins$mean_pseudotime[pseudotime_bins$pseudotime_bin==28]),
                                                                                       unique(pseudotime_bins$mean_pseudotime[pseudotime_bins$pseudotime_bin==33]),
                                                                                       1),include.lowest = T, labels = F)

table(pseudotime_bins$pseudotime_bin_broad)


## Checking for distribution of pseudotime values across stages within each bin
major_samples <- group_by(pseudotime_bins,pseudotime_bin_broad, timepoint) %>%
  dplyr::count() %>%
  mutate(sample=paste(pseudotime_bin_broad, timepoint, sep = "_")) %>%
  filter(n>=100)

ggplot(filter(pseudotime_bins, paste(pseudotime_bin_broad, timepoint, sep = "_") %in% paste(major_samples$sample)), aes(x=as.factor(pseudotime_bin_broad), y=pseudotime, fill=timepoint)) +
  geom_boxplot(notch = T) +
  scale_fill_manual(values = brewer.pal(name = "Spectral", n=11)[3:11])+
  theme_classic()

```

Based on these, it makes sense to make the following comparisons:

1) Bin1: e13-P07
2) Bin2: e15-P07
3) Bin3: e15-P14
4) Bin5: P14-P63

Bin4 is a very dynamic stage, thus we can't uncouple development from differentiation!

We will make separate pseudobulks per broad pseudotime bin and orig.ident (i.e. timepoint and replicate).

As with all our other analyses, we will only consider robust peaks. 

And we will only perform comparisons when we have an adequate number of cells (similar to peak decomposition). In this case we will ask for 100 cells per replicate.

```{r}
cell_counts <- group_by(pseudotime_bins, pseudotime_bin_broad, timepoint, orig.ident) %>%
  dplyr::count() %>%
  full_join(left_join(data.frame(pseudotime_bin_broad=rep(unique(pseudotime_bins$pseudotime_bin_broad), length(unique(pseudotime_bins$orig.ident))), orig.ident = rep(unique(pseudotime_bins$orig.ident), each=length(unique(pseudotime_bins$pseudotime_bin_broad))), stringsAsFactors = F), unique(dplyr::select(pseudotime_bins, timepoint, orig.ident)))) %>%
    mutate(sample=paste(pseudotime_bin_broad, timepoint, sep = "_"))

cell_counts$n[is.na(cell_counts$n)] <- 0

ggplot(cell_counts, aes(x=pseudotime_bin_broad, y=log10(n), fill=orig.ident)) +
  geom_bar(stat="identity", position = "dodge") +
  facet_wrap(~timepoint,nrow = 1) +
  geom_hline(yintercept = log10(100), color="red", lty="dashed") +
    geom_hline(yintercept = log10(50), color="orange", lty="dashed") +
  theme_classic() +
  theme(legend.position = "top")

## Now grouping by pseudotime bin and timepoint and asking whether we meet the condition for both replicates
cell_counts_worse_rep <- group_by(cell_counts, sample) %>%
  summarise(rep_min = min(n))

nrow(cell_counts_worse_rep)
sum(cell_counts_worse_rep$rep_min >= 50)
sum(cell_counts_worse_rep$rep_min >= 100)

## Requiring at least 50 cells per replicate
cell_counts.filtered <- filter(cell_counts, sample %in% cell_counts_worse_rep$sample[cell_counts_worse_rep$rep_min >= 50])

## Now generating the pseudobulks
robust_peaks <- gsub("_", "-", mouse_peaks$peak[mouse_peaks$robust])
atac.data <- atac.seurat@assays$Peaks@counts[robust_peaks,] 

dim(atac.data)

pseudobulks <- do.call(cbind, parallel::mclapply(1:nrow(cell_counts.filtered), function(i){
  cells <- pseudotime_bins$cell[pseudotime_bins$pseudotime_bin_broad==cell_counts.filtered$pseudotime_bin_broad[i] & pseudotime_bins$orig.ident == cell_counts.filtered$orig.ident[i]]
  pseudo <- Matrix::rowSums(atac.data[, cells])
  return(pseudo)
}, mc.cores = 10))
```

```{r}
dim(pseudobulks)

colnames(pseudobulks) <- paste(cell_counts.filtered$pseudotime_bin_broad, cell_counts.filtered$timepoint, cell_counts.filtered$orig.ident, sep = "_")
```

Removing comparisons that aren't justified to make based on pseudotime distribution within the bin:

```{r}
colnames(pseudobulks)

pseudobulks <- pseudobulks[, !(colnames(pseudobulks) %in% c("2_e13_sa001", "2_e13_sa084","2_P14_sa035","2_P14_sa041", "4_P0_sa040" , "4_P0_sa055","4_P04_sa013",  "4_P04_sa024", "4_P07_sa049","4_P07_sa056","4_P14_sa035", "4_P14_sa041", "4_P63_sa036", "4_P63_sa057"))]

colnames(pseudobulks)
```

Now also constructing a design matrix:

```{r}
atac.info <- data.frame(sample_id = colnames(pseudobulks), stringsAsFactors = F) %>%
  separate(sample_id, into = c("pseudotime_bin", "timepoint", "orig.ident"), remove = F)
```

###Running DESeq2 across stages in each pseudotime bin

1. Creating DESeq objects

```{r, eval=FALSE}
atac.deseq_obj <- lapply(unique(atac.info$pseudotime_bin), function(i) {
  atac.deseq_pseudo <- DESeqDataSetFromMatrix(countData = pseudobulks[,atac.info$sample_id[atac.info$pseudotime_bin==i]], colData = atac.info[atac.info$pseudotime_bin==i,], design = ~ timepoint)
  atac.deseq_pseudo <- DESeq(atac.deseq_pseudo)
  return(atac.deseq_pseudo)
})

names(atac.deseq_obj) <- unique(atac.info$pseudotime_bin)

saveRDS(atac.deseq_obj, paste0("~/Mouse_Cereb/015_withinLineages/", lineage,"/Mouse_within", lineage,"_DESeq_across_pseudotime_bins_obj.rds"))
```

2. Collecting DA peaks across adjacent stages

```{r}
atac.deseq_obj <- readRDS(paste0("~/Mouse_Cereb/015_withinLineages/", lineage,"/Mouse_within", lineage,"_DESeq_across_pseudotime_bins_obj.rds"))

getDeseqRes <- function(deseqObj, bin, s1, s2, slot="timepoint") {
  res <- results(deseqObj, contrast=c("timepoint", s2, s1), alpha = 0.05)
  res.df <- data.frame(peak=row.names(deseqObj), res=ifelse(res$padj < 0.05 & abs(res$log2FoldChange) > 0,
                     yes = ifelse(res$log2FoldChange > 0,
                                  yes = "up",
                                  no = "down"),
                     no="no"), stringsAsFactors = F)
  colnames(res.df)[2] <-  paste(bin, s1, s2, sep = "_")
  return(res.df)
}

atac.deseq_pseudo.res <- Reduce(full_join, lapply(unique(atac.info$pseudotime_bin), function(i) {
  timepoints <- unique(atac.info$timepoint[atac.info$pseudotime_bin==i])
  atac.deseq_pseudo.res <- Reduce(full_join,lapply(1:(length(timepoints)-1), function(t) getDeseqRes(atac.deseq_obj[[i]], i,timepoints[t], timepoints[t+1])))
  return(atac.deseq_pseudo.res)
}))

atac.deseq_pseudo.res.gather <- gather(atac.deseq_pseudo.res, -peak, key = "comp", value = "sign", na.rm = F) %>%
  separate(comp, into = c("bin", "timepoint"), remove = F, extra="merge", sep = "_") %>%
  filter(sign %in% c("up", "down")) %>%
  group_by(bin, timepoint, sign, .drop = FALSE) %>%
    dplyr::count() %>%
  ungroup()

atac.deseq_pseudo.res.gather$timepoint <- factor(atac.deseq_pseudo.res.gather$timepoint, levels = unique(atac.deseq_pseudo.res.gather$timepoint))

atac.deseq_pseudo.res.gather$stage <- as.integer(atac.deseq_pseudo.res.gather$timepoint)

ggplot(atac.deseq_pseudo.res.gather, aes(x=timepoint, y=n, fill=sign)) +
  geom_col(position = "dodge") +
  scale_fill_manual(values = c("indianred", "deepskyblue3")) +
  theme_bw() +
  ylab("Number of DA regions") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), panel.grid.minor.x = element_blank(), panel.grid.major.x = element_blank()) +
  facet_wrap(~bin, nrow=1)
```

P14-P63: peaks proximal to developmental and signaling genes, as well as peaks that got upregulated from P7 to P14, get downregulated. IP3 pathway genes (involved in neuronal plasticity) get upregulated.

Let's compare the conservation scores of peaks that get up and down regulated in P0-P04, P7-P14 and P14-P63.

```{r, fig.width=8, fig.height=4}
mouse_peaks_deseq <- left_join(mouse_peaks, mutate(atac.deseq_pseudo.res, peak=gsub("-", "_", peak)))

mouse.deseq.dist <- filter(mouse_peaks_deseq, genomic_class_broad %in% c("Distal", "Intronic"), robust==T) %>%
  dplyr::select(peak, meanPhastCons_100bp, min_age_collapsed, min_age_num,`1_P0_P04`, `2_P0_P04`,`3_P0_P04`,`3_P07_P14`, `5_P14_P63`, `5_P14_P63`) %>%
  gather(-peak, -meanPhastCons_100bp, -min_age_collapsed, -min_age_num, key = "comp", value = "sign", na.rm = T) %>%
  separate(comp, into=c("differentiation", "stage"), sep = "_", extra = "merge", remove = F)


ggplot(filter(mouse.deseq.dist, sign!="no"), aes(x=sign, y=meanPhastCons_100bp, fill=sign))+
  geom_boxplot(notch = T, varwidth = F) +
  scale_fill_manual(values = c("indianred","deepskyblue3")) +
  facet_wrap(~comp, nrow = 1) +
  theme_classic()

filter(mouse.deseq.dist, sign!="no") %>%
  group_by(comp) %>%
  summarise(wilcox.test(meanPhastCons_100bp[sign=="down"], meanPhastCons_100bp[sign=="up"])$p.value)

ggplot(filter(mouse.deseq.dist, sign!="no"), aes(sign, fill=sign))+
  geom_bar() +
  scale_fill_manual(values = c("indianred","deepskyblue3")) +
  facet_wrap(~comp, nrow = 1) +
  theme_classic()
```

Overall, we see that clusters that were active in earlier stages close down in later stages, causing this difference in conservation.

Export data

```{r}
write.table(pseudobulks, paste0("~/Mouse_Cereb/015_withinLineages/", lineage, "/deseq_stages/Mouse_within", lineage, "_pseudotime_deseq_bins_pseudobulks.txt"))

write_tsv(atac.deseq_pseudo.res, paste0("~/Mouse_Cereb/015_withinLineages/", lineage, "/deseq_stages/Mouse_within", lineage, "_pseudotime_deseq_bins_results.txt"))
```

```{r}
sessionInfo()
```

