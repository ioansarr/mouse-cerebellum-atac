---
title: "Mouse Cerebellum - DORCs"
author: "Ioannis Sarropoulos"
date: '`r format(Sys.time(), "%d %B, %Y")`'
output: html_document
---

```{r}
suppressPackageStartupMessages({
  library(tidyverse)
  library(data.table)
  library(viridis)
  library(SummarizedExperiment)
  library(RColorBrewer)
  library(WebGestaltR)
  library(cluster)
  library(ComplexHeatmap)
})
```

```{r}
## Mouse peak info
mouse_peaks <- read.table("~/Mouse_Cereb/006_peaks/Mouse_Cerebellum_reproducible_peaks_summary.txt", header = T, sep = "\t", stringsAsFactors = F)

## All peak2gene connections
peak2gene <- read_tsv("~/Mouse_Cereb/006_peaks/Mouse_Cerebellum_reproducible_peaks_assignment_to_Genes.txt")
```

Here we will try to identify DORCs. Unlike our previous analyses, here we will assign each peak to a single (most correlated gene). This way we make sure that we only include each peak once.

Furthermore, to account for the possible splitting of broad peaks, for each multipeak CRE (very adjacent peaks with highly correlated activity) with the same target gene, we will only consider the peak with the highest correlation to the target gene.

```{r}
top_gene <- filter(peak2gene, peak %in% mouse_peaks$peak[mouse_peaks$robust]) %>%
  group_by(peak) %>%
  summarise(put_target_genes = target_gene[which.max(target_gene_corr)],
            corr=max(target_gene_corr)) %>%
  left_join(dplyr::select(mouse_peaks, peak, multiPeakCRE)) %>%
  group_by(multiPeakCRE, put_target_genes) %>%
  summarise(peak=peak[which.max(corr)], 
            corr=max(corr)) %>%
  left_join(dplyr::select(mouse_peaks, -put_target_genes)) %>%
  filter(robust==T, genomic_class_broad %in% c("Distal", "Intronic"))

nrow(top_gene)
length(unique(top_gene$peak))
table(top_gene$genomic_class_broad)

gene.stats <- group_by(top_gene, put_target_genes) %>%
  summarise(nPeaks=n_distinct(peak),
            phastcons_dist=mean(meanPhastCons_100bp),
            phastcons_dist_glires=mean(meanPhastCons_Glires_100bp),
            minAge_dist=mean(min_age_num))


plot(sort(gene.stats$nPeaks))

sum(gene.stats$nPeaks==gene.stats$nDistal)

hist(gene.stats$phastcons_dist)
hist(gene.stats$phastcons_dist_glires)
hist(gene.stats$minAge_dist)
```

```{r}
arseFromElbow <- function(x, y, plot.it=TRUE, plot.elbow=TRUE, ...)  {
  
  
  # need to re-scale x to match y , and allow for uneven spacing of x values.
  span.x <- max(x) - min(x)
  span.y <- max(y) - min(y)
  x2 <-   min(y) +  (((x-min(x)) / span.x) * span.y) # x2 values are evenly spaced between min and max of y
  
  max.x2 <- max(x2)   # with above scaling, this is equivalent to max(y)
  min.y <- min(y)
  
  br.dist <- sqrt((max.x2 - x2)^2 + (y-min.y)^2 )
  
  if(plot.it) {
    plot(x,y, xaxt='n', ...)
    segments(max(x), min(y), x[which.min(br.dist)], y[which.min(br.dist)])
    
    points(x[which.min(br.dist)], y[which.min(br.dist)] , col="red", pch=19, cex=1.5)
    
    if(plot.elbow)  text(x[which.min(br.dist)], y[which.min(br.dist)], labels=signif(y[which.min(br.dist)], digits=4), adj=c(2,-1), cex=2)
    
  }
  return(y[which.min(br.dist)])
}

arseFromElbow(x=1:length(gene.stats$nPeaks), y=sort(gene.stats$nPeaks))

sum(gene.stats$nPeaks >=5)
```

```{r}
p <- ggplot(data = NULL, aes(x=as.numeric(1:length(gene.stats$nPeaks)), y = as.numeric(sort(gene.stats$nPeaks, decreasing = T)), color=as.factor(sort(gene.stats$nPeaks, decreasing = T)>=5))) +
  geom_path(lwd=0.7) +
  ylab("Number of distal CREs") +
  xlab("Ranked genes") +
  geom_hline(yintercept = 4.8, color="indianred", lty="dashed", lwd=0.5) +
  geom_vline(xintercept = max(which(sort(gene.stats$nPeaks, decreasing = T)>=5)), color="indianred", lty="dashed", lwd=0.5) +
  scale_color_manual(values=c("gray50", "deepskyblue3"), guide=F) +
  scale_x_continuous(breaks = seq(0, 9000, 1000)) +
  theme_classic()

p

if(dir.exists("~/Mouse_Cereb/Figures/009_targetGenes")==F) {
  dir.create("~/Mouse_Cereb/Figures/009_targetGenes", recursive = T)
}

pdf("~/Mouse_Cereb/Figures/009_targetGenes/Mouse_peaks_DORCs_5_distalPeaks_cutoff.pdf", width = 4, height = 4, useDingbats = F); print(p); dev.off()
```

Let's use 5 as a cutoff here

```{r}
dorcs <- gene.stats$put_target_genes[gene.stats$nPeaks >=5]
gene.symbols <- read.table("~/Data/scATAC_pipeline_v3/resources/mouse_coding_ens94_gene_symbols.txt", header = T, stringsAsFactors = F)
```

First, let's see what we know about these genes.

Let's run a quick enrichment analysis

```{r}
WebGestaltR(enrichMethod = "ORA",
            organism = "mmusculus",
            enrichDatabase = "geneontology_Biological_Process_noRedundant",
            interestGene = unique(na.omit(gene.symbols$ensembl[gene.symbols$symbol %in% dorcs])),
            interestGeneType = "ensembl_gene_id",
            referenceGene = unique(na.omit(gene.symbols$ensembl[gene.symbols$symbol %in% gene.stats$put_target_genes])),
            referenceGeneType = "ensembl_gene_id",
            fdrMethod = "BH", sigMethod = "fdr", fdrThr = 0.05,
            outputDirectory = "~/Mouse_Cereb/009_peak2gene/dorcs/" ,projectName = 'DORCs_5peaks_BiologicalProcess_distal')

WebGestaltR(enrichMethod = "ORA",
            organism = "mmusculus",
            enrichDatabase = "geneontology_Molecular_Function_noRedundant",
            interestGene = unique(na.omit(gene.symbols$ensembl[gene.symbols$symbol %in% dorcs])),
            interestGeneType = "ensembl_gene_id",
            referenceGene = unique(na.omit(gene.symbols$ensembl[gene.symbols$symbol %in% gene.stats$put_target_genes])),
            referenceGeneType = "ensembl_gene_id",
            fdrMethod = "BH", sigMethod = "fdr", fdrThr = 0.05,
            outputDirectory = "~/Mouse_Cereb/009_peak2gene/dorcs/" ,projectName = 'DORCs_5peaks_MolecularFunction_distal')
```

```{r}
dorc_bp <- read_tsv("~/Mouse_Cereb/009_peak2gene/dorcs/Project_DORCs_5peaks_BiologicalProcess_distal/enrichment_results_DORCs_5peaks_BiologicalProcess_distal.txt")

p <- ggplot(dorc_bp, aes(x=overlap, y=reorder(description, overlap), color = -log10(pValue)))+
  geom_point(aes(size=enrichmentRatio)) +
  scale_color_gradient(low = "yellow", high="red", name='-log'[10]~' p-value') +
  scale_size_continuous(name="Enrichment") +
  ylab("") +
  ggtitle("Biological Process") +
  xlab("Count") +
  theme_bw()

pdf("~/Mouse_Cereb/Figures/009_targetGenes/Mouse_peaks_DORCs_5_distalPeaks_BPenrichment.pdf", width = 7, height = 5, useDingbats = F); print(p); dev.off()
```


Associated with membrane transporters, developmental genes, axon guidance, cell adhesion, TFs etc.

These sound like reasonable terms.

We should profile their activity throughout the dataset. But before we get there, let's have a look at the really burning question. What's the cluster distribution of the associated peaks?

```{r}
summary(gene.stats$nPeaks[gene.stats$put_target_genes %in% dorcs])

dorc_peaks <- filter(top_gene, put_target_genes %in% dorcs)

nrow(dorc_peaks)
```

7.5K distal peaks associated with 1,000 genes (median 6 peaks, mean 7).

Let's recover the lineage clusters (global CRE activity) for these peaks:

```{r}
lin_clust <- readRDS("~/Mouse_Cereb/013_globalCREactivity/Mouse_peaks_lineage_by_t_FinalClusters.rds")

dorc_peaks <- data.frame(peak=names(lin_clust), globalClust=lin_clust, stringsAsFactors = F) %>%
  right_join(dorc_peaks)

dorc_by_clust_precise <- group_by(dorc_peaks, put_target_genes, globalClust) %>%
  dplyr::count() %>%
  ungroup() %>%
  group_by(put_target_genes) %>%
  summarise(top_clust=globalClust[which.max(n)],
            n_top_clust=max(n)) %>%
  right_join(dorc_peaks) %>%
  group_by(put_target_genes, top_clust, n_top_clust) %>%
  summarise(nPeaks=n(),
            nClust=n_distinct(globalClust)) %>%
  mutate(f_top_clust=n_top_clust/nPeaks)


ggplot(dorc_by_clust_precise, aes(x=log10(nPeaks), y=nClust, color=f_top_clust)) +
  geom_point(position = position_jitter(width = 0.1)) +
  geom_text(aes(label=put_target_genes), check_overlap = T)
```

Now let's also profile the activity of these DORCs in the dataset (at least at the level of cell type x timepoint).
Since we have a fixed-width and 1:1 matches, we can just estimate the mean CPM across all peaks in each sample.

```{r, fig.width=7, fig.height=7}
lineage.cpm <- read.table("~/Mouse_Cereb/013_globalCREactivity/Mouse_lineage_by_timepoint_pseudobulk_cpm.txt", header = T, sep = "\t", stringsAsFactors = F)

dorc_activity <- do.call(rbind,lapply(unique(dorc_peaks$put_target_genes), function(g) {
  colMeans(lineage.cpm[dorc_peaks$peak[dorc_peaks$put_target_genes==g],])
}))

colnames(dorc_activity) <- colnames(lineage.cpm)

row.names(dorc_activity) <- unique(dorc_peaks$put_target_genes)

## Standardising
dorc_activity.std <-dorc_activity/apply(dorc_activity, 1, max)

dorc_activity.std <- dorc_activity.std[, c(colnames(dorc_activity.std)[grepl("Astroglia",colnames(dorc_activity.std))],
                                       colnames(dorc_activity.std)[grepl("Parabrachial",colnames(dorc_activity.std))],
                                       colnames(dorc_activity.std)[grepl("GABA_DN",colnames(dorc_activity.std))],
                                       colnames(dorc_activity.std)[grepl("Isthmic_nuclei",colnames(dorc_activity.std))],
                                       colnames(dorc_activity.std)[grepl("Glut_DN",colnames(dorc_activity.std))],
                                       colnames(dorc_activity.std)[grepl("MBO",colnames(dorc_activity.std))],
                                       colnames(dorc_activity.std)[grepl("PC",colnames(dorc_activity.std))],
                                       colnames(dorc_activity.std)[grepl("Interneuron",colnames(dorc_activity.std))],
                                       colnames(dorc_activity.std)[grepl("GC",colnames(dorc_activity.std))],
                                       colnames(dorc_activity.std)[grepl("UBC",colnames(dorc_activity.std))],
                                       colnames(dorc_activity.std)[grepl("Oligodendrocyte",colnames(dorc_activity.std))],
                                       colnames(dorc_activity.std)[grepl("Microglia",colnames(dorc_activity.std))])]

pheatmap::pheatmap(dorc_activity.std[sample(1:nrow(dorc_activity), 100),], clustering_distance_cols = "correlation", clustering_distance_rows = "correlation", show_rownames = F, cluster_cols = F)
```

```{r}
cell_anno <- readRDS("~/Mouse_Cereb/004_cellTypes_broad/Mouse_Cerebellum_atac_finalCellType_annotation.rds")
cell_anno <- dplyr::select(cell_anno, Cell_type_broad, Cell_type_broad_color) %>%
  unique()

cell_type <- sapply(colnames(dorc_activity.std), function(x) {
  comp <- str_split(x, "_", simplify = T)
  cell <- paste(comp[1:(length(comp) -1)], collapse = "_")
})

cell_type

cell_type_cols <- sapply(unique(cell_type), function(x) cell_anno$Cell_type_broad_color[cell_anno$Cell_type_broad==x])
names(cell_type_cols) <- unique(cell_type)

timepoint <- sapply(colnames(dorc_activity.std), function(x) {
  comp <- str_split(x, "_", simplify = T)
  t <- comp[length(comp)]
})

timepoint_cols <- RColorBrewer::brewer.pal(11, "Spectral")
names(timepoint_cols) <- unique(timepoint)

ha = HeatmapAnnotation(cell_type = cell_type, stage=timepoint, col=list(cell_type=cell_type_cols, stage=timepoint_cols),annotation_name_side = "left", annotation_legend_param = list(direction = "horizontal",nrow = 1))
```

Clustering peaks

```{r}
ks <- c(2:10)
length(ks)

clust_opt <- do.call(rbind,lapply(ks, function(k){
    cl <- kmeans(dorc_activity.std, centers = k, nstart = 25, iter.max = 100)
    wws <- cl$tot.withinss
    ss <- silhouette(cl$cluster, as.dist(1-cor(t(dorc_activity.std))))
    return(c(k,wws, mean(ss[,3])))
  }))
clust_opt <- as.data.frame(clust_opt)
colnames(clust_opt) <- c("k", "wws", "sil")

ggplot(clust_opt, aes(x=k, y=wws)) +
  geom_point() +
  geom_line() +
  theme_classic()

ggplot(clust_opt, aes(x=k, y=sil)) +
  geom_point() +
  geom_line() +
  theme_classic()
```

The optimal number of clusters seems to be 5.

```{r}
set.seed(1)
dorc_clust <- kmeans(dorc_activity.std, centers = 5, nstart = 50, iter.max = 200)
```


Now making the heatmap. 

```{r, fig.height=8, fig.width=8}
row.names(dorc_activity.std)

interesting_genes <- which(row.names(dorc_activity.std) %in% c("Pax3", "Car10", "Atoh1", "Ptf1a", "Olig2", "Sox14", "Zic1", "Gdf10", "Kirrel2", "Cbln1", "Barhl1", "Sox2", "Etv1", "Grin2a", "Syn2"))

gene_ha = rowAnnotation(foo = anno_mark(at = interesting_genes, labels =row.names(dorc_activity.std)[interesting_genes]), annotation_legend_param = list(direction = "horizontal",nrow = 1, labels_gp = gpar(fontsize = 1)))

draw(Heatmap(matrix = dorc_activity.std,
        row_split =dorc_clust$cluster ,
        cluster_rows = F,
        cluster_columns = F,
        show_row_names = F,
        col=colorRampPalette(brewer.pal(n=9,name = "Blues"))(100),
        cluster_row_slices=T,
        border = TRUE,
        top_annotation = ha,
        right_annotation = gene_ha,
        heatmap_legend_param = list( title = "Scaled activity")), heatmap_legend_side = "left", annotation_legend_side = "top")
```

```{r}
pdf("~/Mouse_Cereb/Figures/009_targetGenes//Mouse_peaks_DORCs_5_distalPeaks_activityHeatmap_k5.pdf", width=8, height = 8, useDingbats = F);draw(Heatmap(matrix = dorc_activity.std,
        row_split =dorc_clust$cluster ,
        cluster_rows = F,
        cluster_columns = F,
        show_row_names = F,
        col=colorRampPalette(brewer.pal(n=9,name = "Blues"))(100),
        cluster_row_slices=T,
        border = TRUE,
        top_annotation = ha,
        right_annotation = gene_ha,
        heatmap_legend_param = list( title = "Scaled activity")), heatmap_legend_side = "left", annotation_legend_side = "top");dev.off()
```


Let's also associate the clusters with BPs.

```{r, fig.height=6, fig.width=8}
library("clusterProfiler")
library(org.Mm.eg.db)

clust_genes <- lapply(sort(unique(dorc_clust$cluster)), function(c) {
  genes <- names(dorc_clust$cluster[dorc_clust$cluster==c])
  return(genes)
})

names(clust_genes) <- sort(unique(dorc_clust$cluster))

names(clust_genes)

ck <- compareCluster(geneCluster = clust_genes,
                     fun = "enrichGO",
                     OrgDb         = org.Mm.eg.db,
                     keyType       = 'SYMBOL',
                     ont           = "BP",
                     pAdjustMethod = "BH",
                     pvalueCutoff  = 0.01,
                     qvalueCutoff  = 0.05)

dotplot(ck, showCategory=5)
```


If we compare this to our peak clusters, we see that DORC genes have much more broad profiles. We can basically distinguish them to those active in late interneurons (GCs, Pax2, UBCs), differentiating GCs, interneurons, glial genes, and genes active in early progenitors/differentiating neurons.

To show that this is the case, we can also perform clustering with the same k as our peak (26).

```{r, fig.height=8, fig.width=8}
draw(Heatmap(matrix = dorc_activity.std,
        cluster_rows = F,km = 26,
        cluster_columns = F,
        show_row_names = F,
        col=colorRampPalette(brewer.pal(n=9,name = "Blues"))(100),
        cluster_row_slices=T,
        border = TRUE,
        top_annotation = ha,
        heatmap_legend_param = list( title = "Scaled activity")), heatmap_legend_side = "left", annotation_legend_side = "top")
```

```{r}
pdf("~/Mouse_Cereb/Figures/009_targetGenes//Mouse_peaks_DORCs_5_distalPeaks_activityHeatmap_k26.pdf", width=6, height = 8, useDingbats = F);draw(Heatmap(matrix = dorc_activity.std,
        cluster_rows = F,km = 26,
        cluster_columns = F,
        show_row_names = F,
        col=colorRampPalette(brewer.pal(n=9,name = "Blues"))(100),
        cluster_row_slices=T,
        border = TRUE,
        top_annotation = ha,
        heatmap_legend_param = list( title = "Scaled activity")), heatmap_legend_side = "left", annotation_legend_side = "top");dev.off()
```
We see that we get a large number of very similar clusters. Also each cluster still shows activity in multiple cell types.

What are the conclusions here:

1. We validate that most genes associated with many peaks are active in late development and adulthood.
2. We see that many of these genes are shared across multiple cell types. However, we already know that most of the peaks associated with these genes are highly cell type-specific.

This allows us to proceed in two directions:

1. Identify peaks regulating the same gene but active in different cell types/stages (ex. Nrg2)
2. Identify peaks regulating the same gene in the same cell type and stage (i.e. shadow enhancers)

What about genes associated with mostly similar vs different peaks?

Do we have differences across these clusters?

```{r}
dorc_by_clust_precise<- data.frame(put_target_genes=names(dorc_clust$cluster), dorc_clust=dorc_clust$cluster, stringsAsFactors = F) %>%
  right_join(dorc_by_clust_precise)

ggplot(dorc_by_clust_precise, aes(as.factor(dorc_clust), y=f_top_clust)) +
  geom_boxplot(notch = T)
```

Yes, but maybe the fraction in the top cluster isn't the optimal metric here. As a more direct metric, we can instead try to compute the average correlation of accessibility between the peaks that are assigned to the same gene.

However, our power to detect correlations depends on the activity profile of the peaks/gene. To account for these differences, rather than directly comparing correlations between peaks, we will compare them to their correlation to the target gene.

The main idea here is the following:
Pleiotropic peaks: mean(peak-peak_cor) ~= mean(peak-gene_cor)
Cell-type specific peaks: mean(peak-peak_cor) << mean(peak-gene_cor)

We should work on the space of broad cell type x timepoint as that's where we profiled dorc activity as well.

```{r}
atac.data <- read.table("~/Mouse_Cereb/013_globalCREactivity/Mouse_lineage_by_timepoint_pseudobulk_cpm_std.txt", header = T, sep = "\t", stringsAsFactors = F)

atac.data <- atac.data[, colnames(dorc_activity.std)]

dim(atac.data)
  
meanPeakPeak_Cor <- sapply(unique(dorc_by_clust_precise$put_target_genes), function(g) {
  peaks <- dorc_peaks$peak[dorc_peaks$put_target_genes==g]
  atac.sub <- atac.data[peaks,]
  peak_cor <- cor(t(atac.sub), method="spearman")
  return(mean(peak_cor[upper.tri(peak_cor)]))
})

meanPeakGene_Cor <- sapply(unique(dorc_by_clust_precise$put_target_genes), function(g) {
  peaks <- dorc_peaks$peak[dorc_peaks$put_target_genes==g]
  atac.sub <- atac.data[peaks,]
  peakGene_cor <- sapply(1:nrow(atac.sub), function(i) cor(as.numeric(atac.sub[i,]), as.numeric(dorc_activity.std[g,]), method="spearman"))
  return(mean(peakGene_cor))
})

hist(meanPeakPeak_Cor, breaks = 50)
hist(meanPeakGene_Cor, breaks = 50)
hist(meanPeakPeak_Cor-meanPeakGene_Cor, breaks = 50)
hist((meanPeakPeak_Cor-meanPeakGene_Cor)/meanPeakGene_Cor, breaks = 50)

dorc_by_clust_precise$meanPeakPeak_Cor <- meanPeakPeak_Cor
dorc_by_clust_precise$meanPeakGene_Cor <- meanPeakGene_Cor
dorc_by_clust_precise$Cor_dif <- meanPeakPeak_Cor-meanPeakGene_Cor
dorc_by_clust_precise$Cor_ratio <-  meanPeakPeak_Cor / meanPeakGene_Cor

hist(dorc_by_clust_precise$Cor_dif, breaks = 50)
hist(dorc_by_clust_precise$Cor_dif[dorc_by_clust_precise$meanPeakGene_Cor > 0.5], breaks = 50)

ggplot(dorc_by_clust_precise, aes(as.factor(dorc_clust), y=f_top_clust)) +
  geom_boxplot(notch = T)

ggplot(dorc_by_clust_precise, aes(as.factor(dorc_clust), y=meanPeakPeak_Cor)) +
  geom_boxplot(notch = T)

ggplot(dorc_by_clust_precise, aes(as.factor(dorc_clust), y=Cor_dif)) +
  geom_boxplot(notch = T)

ggplot(dorc_by_clust_precise, aes(x=meanPeakGene_Cor, y=Cor_dif)) +
  geom_point(alpha=0.5) +
  geom_text(aes(label=put_target_genes), check_overlap = T)

ggplot(filter(dorc_by_clust_precise,meanPeakGene_Cor > 0.5), aes(x=meanPeakGene_Cor, y=meanPeakPeak_Cor)) +
  geom_point(alpha=0.5) +
  geom_text(aes(label=put_target_genes), check_overlap = T)

ggplot(filter(dorc_by_clust_precise,meanPeakGene_Cor > 0.5), aes(x=f_top_clust, y=Cor_dif, color=meanPeakPeak_Cor)) +
  geom_point(alpha=0.5) +
  geom_text(aes(label=put_target_genes), check_overlap = T)

ggplot(dorc_by_clust_precise, aes(x=f_top_clust, y=meanPeakPeak_Cor, color=meanPeakGene_Cor)) +
  geom_point(alpha=0.5) +
  geom_text(aes(label=put_target_genes), check_overlap = T)


hist(dorc_by_clust_precise$f_top_clust, breaks = 20)

peaks <- dorc_peaks$peak[dorc_peaks$put_target_genes=="Cwc22"]
pheatmap::pheatmap(atac.data[peaks,], cluster_cols = F)

peaks <- dorc_peaks$peak[dorc_peaks$put_target_genes=="Zic4"]
pheatmap::pheatmap(atac.data[peaks,], cluster_cols = F)

peaks <- dorc_peaks$peak[dorc_peaks$put_target_genes=="Rmst"]
pheatmap::pheatmap(atac.data[peaks,], cluster_cols = F)

peaks <- dorc_peaks$peak[dorc_peaks$put_target_genes=="Acot7"]
pheatmap::pheatmap(atac.data[peaks,], cluster_cols = F)

peaks <- dorc_peaks$peak[dorc_peaks$put_target_genes=="Nrg2"]
pheatmap::pheatmap(atac.data[peaks,], cluster_cols = F)

peaks <- dorc_peaks$peak[dorc_peaks$put_target_genes=="Slc17a6"]
pheatmap::pheatmap(atac.data[peaks,], cluster_cols = F)

peaks <- dorc_peaks$peak[dorc_peaks$put_target_genes=="Elmo2"]
pheatmap::pheatmap(atac.data[peaks,], cluster_cols = F)

peaks <- dorc_peaks$peak[dorc_peaks$put_target_genes=="Gabrd"]
pheatmap::pheatmap(atac.data[peaks,], cluster_cols = F)
```

```{r, fig.width=7, fig.height=5}
res <- sapply(unique(dorc_by_clust_precise$put_target_genes), function(g) {
  peaks <- dorc_peaks$peak[dorc_peaks$put_target_genes==g]
  atac.sub <- atac.data[peaks,]
  res <- sapply(1:nrow(atac.sub), function(i) sum(abs(as.numeric(dorc_activity.std[g,] - as.numeric(atac.sub[i,])))))
  return(mean(res))
})

hist(res)

## The total residuals mostly correlate with the breadth of the gene!
plot(rowSums(dorc_activity.std[unique(dorc_by_clust_precise$put_target_genes),]), res)
cor(rowSums(dorc_activity.std[unique(dorc_by_clust_precise$put_target_genes),]), res)

## We have to standardise them, but dividing with the sum of activity gives very high residuals for cell type specific genes. Let's scale by the square root of the activity sum instead.
res.std <- res/sqrt(rowSums(dorc_activity.std[unique(dorc_by_clust_precise$put_target_genes),]))

plot(rowSums(dorc_activity.std[unique(dorc_by_clust_precise$put_target_genes),]), res.std)
cor(rowSums(dorc_activity.std[unique(dorc_by_clust_precise$put_target_genes),]), res.std)

dorc_by_clust_precise$res <- res.std
dorc_by_clust_precise$activity_sum <- rowSums(dorc_activity.std[unique(dorc_by_clust_precise$put_target_genes),])

ggplot(filter(dorc_by_clust_precise), aes(x=activity_sum, y=res, color=meanPeakPeak_Cor)) +
  geom_point(alpha=0.5) +
  geom_text(aes(label=put_target_genes), check_overlap = T)

ggplot(filter(dorc_by_clust_precise), aes(x=f_top_clust, y=res, color=meanPeakPeak_Cor)) +
  geom_point(alpha=0.5) +
  geom_text(aes(label=put_target_genes), check_overlap = T)

ggplot(filter(dorc_by_clust_precise), aes(x=meanPeakPeak_Cor, y=res, color=f_top_clust)) +
  geom_point(alpha=0.5) +
  geom_text(aes(label=put_target_genes), check_overlap = T)

ggplot(dorc_by_clust_precise, aes(x=as.factor(dorc_clust), y=f_top_clust)) +
  geom_boxplot(notch = T)

ggplot(dorc_by_clust_precise, aes(x=as.factor(dorc_clust), y=res)) +
  geom_boxplot(notch = T)

## Let's use both metrics to identify genes primarily relying on redundant CREs vs those having modular contributions in gene expression

hist(dorc_by_clust_precise$res, breaks = 50)
quantile(dorc_by_clust_precise$res, 0.1, na.rm=T)
quantile(dorc_by_clust_precise$res, 0.9, na.rm=T)
hist(dorc_by_clust_precise$f_top_clust)
quantile(dorc_by_clust_precise$f_top_clust, 0.2, na.rm=T)


sum(na.omit(dorc_by_clust_precise$f_top_clust) <= 0.4)
sum(na.omit(dorc_by_clust_precise$f_top_clust) >= 0.7)

redundant <- filter(dorc_by_clust_precise, res <= 1.7  & f_top_clust >= 0.7)
modular <- filter(dorc_by_clust_precise, res >= 2.45 & f_top_clust <= 0.4) 

dorc_by_clust_precise$class <- ifelse(dorc_by_clust_precise$put_target_genes %in% modular$put_target_genes, yes = "modular", no = ifelse(dorc_by_clust_precise$put_target_genes %in% redundant$put_target_genes, yes = "redundant", no = "other"))

p <- ggplot(filter(dorc_by_clust_precise), aes(x=f_top_clust, y=res, color=class)) +
  geom_point(alpha=0.5, position = position_jitter(width = 0.05)) +
  scale_color_manual(values = c("mediumorchid3", "gray80", "deepskyblue3")) +
  geom_text(data=filter(dorc_by_clust_precise, class %in% c("redundant", "modular"), grepl("Rik$|^Mir[0-9]*", put_target_genes)==F),aes(label=put_target_genes), check_overlap = T) +
  ylab("Mean residuals (gene-peaks), scaled by gene activity") +
  xlab("Fraction of peaks in most common cluster") +
  theme_classic()

p

pdf("~/Mouse_Cereb/Figures/009_targetGenes/Mouse_peaks_DORCs_5_distalPeaks_classification_Redundant_vs_Modular.pdf", width = 6, height = 5, useDingbats = F); print(p); dev.off()
```

```{r}
lapply(redundant$put_target_genes, function(g) pheatmap::pheatmap(atac.data[dorc_peaks$peak[dorc_peaks$put_target_genes==g],],cluster_cols = F, main=g))
```

```{r}
lapply(modular$put_target_genes, function(g) pheatmap::pheatmap(atac.data[dorc_peaks$peak[dorc_peaks$put_target_genes==g],],cluster_cols = F, main=g))
```

We can later select some examples to plot together with gene activity.


Let's run GSEA on these variables

```{r}
class_genes <- lapply(unique(dorc_by_clust_precise$class), function(c) {
  genes <- dorc_by_clust_precise$put_target_genes[dorc_by_clust_precise$class==c]
  return(genes)
})

names(class_genes) <- unique(dorc_by_clust_precise$class)

names(class_genes)

ck_class <- compareCluster(geneCluster = class_genes,
                     fun = "enrichGO",
                     OrgDb         = org.Mm.eg.db,
                     keyType       = 'SYMBOL',
                     ont           = "BP",
                     pAdjustMethod = "BH",
                     pvalueCutoff  = 0.01,
                     qvalueCutoff  = 0.05)

dotplot(ck_class, showCategory=10)
```

We can also use WebGestalt

```{r}
WebGestaltR(enrichMethod = "ORA",
            organism = "mmusculus",
            enrichDatabase = "geneontology_Biological_Process_noRedundant",
            interestGene = unique(na.omit(gene.symbols$ensembl[gene.symbols$symbol %in% dorc_by_clust_precise$put_target_genes[dorc_by_clust_precise$class=="modular"]])),
            interestGeneType = "ensembl_gene_id",
            referenceGene = unique(na.omit(gene.symbols$ensembl[gene.symbols$symbol %in% dorc_by_clust_precise$put_target_genes])),
            referenceGeneType = "ensembl_gene_id",
            fdrMethod = "BH", sigMethod = "top", topThr = 10,
            outputDirectory = "~/Mouse_Cereb/009_peak2gene/dorcs/" ,projectName = 'DORCs_5peaks_ModularPeaks_BiologicalProcess_distal')


WebGestaltR(enrichMethod = "ORA",
            organism = "mmusculus",
            enrichDatabase = "geneontology_Biological_Process_noRedundant",
            interestGene = unique(na.omit(gene.symbols$ensembl[gene.symbols$symbol %in% dorc_by_clust_precise$put_target_genes[dorc_by_clust_precise$class=="redundant"]])),
            interestGeneType = "ensembl_gene_id",
            referenceGene = unique(na.omit(gene.symbols$ensembl[gene.symbols$symbol %in% dorc_by_clust_precise$put_target_genes])),
            referenceGeneType = "ensembl_gene_id",
            fdrMethod = "BH", sigMethod = "top", topThr = 10,
            outputDirectory = "~/Mouse_Cereb/009_peak2gene/dorcs/" ,projectName = 'DORCs_5peaks_RedundantPeaks_BiologicalProcess_distal')
```

We don't really get very meaningful enrichments here.

Which DORC clusters are enriched for which class?

```{r}
p <- ggplot(filter(dorc_by_clust_precise), aes(dorc_clust, fill=class)) +
  geom_bar(position = "fill") +
  scale_fill_manual(values = c("mediumorchid3", "gray80", "deepskyblue3"), name="multi-peak\ninteraction") +
  geom_hline(yintercept = sum(dorc_by_clust_precise$class=="redundant")/nrow(dorc_by_clust_precise), color="deepskyblue4", lty="dashed") +
  geom_hline(yintercept = 1-sum(dorc_by_clust_precise$class=="modular")/nrow(dorc_by_clust_precise), color="mediumorchid4", lty="dashed") +
  ylab("Fraction") +
  xlab("Gene activity cluster") +
    geom_text(stat='count',aes(label=..count..), position = position_fill(vjust = 0.5)) +
  theme_classic()

p 

pdf("~/Mouse_Cereb/Figures/009_targetGenes/Mouse_peaks_DORCs_5_distalPeaks_classification_Redundant_vs_Modular_byCluster.pdf", width = 5, height = 4, useDingbats = F); print(p); dev.off()
```

Clusters 1,3 and 5 (neuron development) are enriched for modular interactions, whereas cluster 2 (gliogenesis) and to some degree 4 (mature neurons) have a larger fraction of redundant peaks.

Can we also see this in the pleiotropy stats from the evodevo data?

Maybe we can go back and have a look into the evodevo stats of these genes (pleiotropy, early vs late).

```{r}
mouse_expr <- read_tsv("~/Resources/Cardoso_etal_Nature_2019/Cardoso_etal_Nature_2019_ST3_MouseGenes_expressionStats.txt")

gene.symbols <- read.table("~/Data/scATAC_pipeline_v3/resources/mouse_coding_ens94_gene_symbols.txt", header = T, stringsAsFactors = F)
colnames(gene.symbols) <- c("Mouse_ID", "put_target_genes")

dorc_by_clust_precise.expr <- left_join(dorc_by_clust_precise, gene.symbols) %>%
  left_join(mouse_expr) 

give.n <- function(x){
   return(c(y = mean(x), label = length(x)))
}

ggplot(dorc_by_clust_precise.expr, aes(x=class, y= TissueTau, fill=class)) +
  geom_boxplot(notch = T) +
  stat_summary(fun.data = give.n, geom = "text", position = position_nudge(y=0.1)) +
  scale_fill_manual(values = c("mediumorchid3", "gray80", "deepskyblue3")) +
  theme_classic()

wilcox.test(na.omit(dorc_by_clust_precise.expr$TissueTau[dorc_by_clust_precise.expr$class=="redundant"]), na.omit(dorc_by_clust_precise.expr$TissueTau[dorc_by_clust_precise.expr$class=="other"]))

wilcox.test(na.omit(dorc_by_clust_precise.expr$TissueTau[dorc_by_clust_precise.expr$class=="redundant"]), na.omit(dorc_by_clust_precise.expr$TissueTau[dorc_by_clust_precise.expr$class=="modular"]))

ggplot(dorc_by_clust_precise.expr, aes(x=class, y= CerebellumTau, fill=class)) +
  geom_boxplot(notch = T)+
  stat_summary(fun.data = give.n, geom = "text", position = position_nudge(y=0.05)) +
  scale_fill_manual(values = c("mediumorchid3", "gray80", "deepskyblue3")) +
  theme_classic()

wilcox.test(na.omit(dorc_by_clust_precise.expr$CerebellumTau[dorc_by_clust_precise.expr$class=="redundant"]), na.omit(dorc_by_clust_precise.expr$CerebellumTau[dorc_by_clust_precise.expr$class=="other"]))

ggplot(filter(dorc_by_clust_precise.expr, is.na(Cerebellum_pattern)==F), aes(Cerebellum_pattern, fill=class)) +
  geom_bar(position = "fill") +
  scale_fill_manual(values = c("mediumorchid3", "gray80", "deepskyblue3")) +
   geom_text(stat='count',aes(label=..count..), position = position_fill(vjust = 0.5)) +
  theme_classic()
```

```{r}
p <- ggplot(dorc_by_clust_precise.expr, aes(x=class, y= TissueTau, fill=class)) +
  geom_boxplot(notch = T) +
  stat_summary(fun.data = give.n, geom = "text", position = position_nudge(y=0.1)) +
  scale_fill_manual(values = c("mediumorchid3", "gray80", "deepskyblue3")) +
  xlab("Multi-peak interaction") +
  ylab("Gene tissue-specificity (Tau)") +
  theme_classic()

p

pdf("~/Mouse_Cereb/Figures/009_targetGenes/Mouse_peaks_DORCs_5_distalPeaks_classification_Redundant_vs_Modular_TissueTau.pdf", width = 3.5, height = 4, useDingbats = F); print(p); dev.off()
```

We only have few genes and these are very weak patterns. Therefore, it's likely better to mostly comment on the fact that genes with a large number of redundant CREs seem to be active in a limited number of cell types and stages (both from the heatmap and suggested by the Tissue and Cerebellum Tau indexes, as well as the DORC activity patterns themselves).

Instead, genes associated with CREs with a modular contribution to their expression are often expressed in multiple cell types and stages.

Now let's focus on the redundant CREs. These could be both elements of super enhancers (work from Young) as well as shadow/redundant enhancers (Osterwalder Nature).

Here we don't need to specifically focus on the genes primarily associated with redundant peaks, as other genes can also have more than one distal peaks with the same target gene and highly correlated activity.

However, we need to limit our analysis to:
1) Distal peaks (intergenic and intronic)
2) Exclude broad peaks

```{r}
## Considering distal CRE peaks
redundant_peak_candidates <- top_gene

## Asking for peaks to be assigned to a target gene with at least two peaks
redundant_peak_candidates_gene_count <- group_by(redundant_peak_candidates, put_target_genes) %>%
  dplyr::count()

summary(redundant_peak_candidates_gene_count$n)

## Keeping peaks uniquely assigned to one target gene as controls
unique_peaks <- filter(redundant_peak_candidates, put_target_genes %in% redundant_peak_candidates_gene_count$put_target_genes[redundant_peak_candidates_gene_count$n == 1])

## The rest remain as candidates for redundancy
redundant_peak_candidates <- filter(redundant_peak_candidates, put_target_genes %in% redundant_peak_candidates_gene_count$put_target_genes[redundant_peak_candidates_gene_count$n > 1])

## How many genes are we considering?
length(unique(redundant_peak_candidates$put_target_genes))

## That's more than double compared to our DORCs!

## Now let's compute correlations across the putatively redundant peaks.
## Here we can go back to our pseudocells:
atac.pseudocells <- readRDS("~/Mouse_Cereb/proj4_chromVar/Peak2GeneLinks/seATAC-Group-KNN.rds")

atac.pseudocells.data <- assay(atac.pseudocells)
row.names(atac.pseudocells.data) <- paste(seqnames(atac.pseudocells@rowRanges), start(atac.pseudocells@rowRanges), end(atac.pseudocells@rowRanges), sep="_")

peak_cor <- Reduce(bind_rows,lapply(unique(redundant_peak_candidates$put_target_genes), function(g) {
  peaks <- redundant_peak_candidates$peak[redundant_peak_candidates$put_target_genes==g]
  atac.sub <- atac.pseudocells.data[peaks,]
  peak_cor <- cor(t(atac.sub))
  ut <- upper.tri(peak_cor)
  cor.df <- data.frame(
    gene=g,
    peak_1=rownames(peak_cor)[row(peak_cor)[ut]],
    peak_2 = rownames(peak_cor)[col(peak_cor)[ut]],
    corr=peak_cor[upper.tri(peak_cor)],
    stringsAsFactors = F
  )
  return(cor.df)
}))

hist(peak_cor$corr, breaks = 100)

## Adding the correlation of peak1 and peak2 to the gene.
## ALso incorporating information about conservation
peak_cor <- left_join(peak_cor, dplyr::rename(dplyr::select(peak2gene, peak, target_gene, target_gene_corr), peak_1=peak, gene=target_gene,  gene_corr_1=target_gene_corr)) %>%
  left_join(dplyr::rename(dplyr::select(peak2gene, peak, target_gene, target_gene_corr), peak_2=peak, gene=target_gene,  gene_corr_2=target_gene_corr)) %>%
  left_join(dplyr::rename(peak_1=peak, phastcons_1 = meanPhastCons_100bp, phastcons_glires_1=meanPhastCons_Glires_100bp, age_1=min_age_num,dplyr::select(mouse_peaks, peak, meanPhastCons_100bp, meanPhastCons_Glires_100bp, min_age_num))) %>%
  left_join(dplyr::rename(peak_2=peak, phastcons_2 = meanPhastCons_100bp, phastcons_glires_2=meanPhastCons_Glires_100bp, age_2=min_age_num,dplyr::select(mouse_peaks, peak, meanPhastCons_100bp, meanPhastCons_Glires_100bp, min_age_num)))
peak_cor$gene_corr_mean <- rowMeans(peak_cor[,c("gene_corr_1", "gene_corr_2")])

cor(peak_cor$gene_corr_1, peak_cor$gene_corr_2)
cor(peak_cor$gene_corr_1, peak_cor$corr)
cor(peak_cor$gene_corr_2, peak_cor$corr)

hist(peak_cor$gene_corr_mean - peak_cor$corr, breaks = 50)
summary(peak_cor$gene_corr_mean - peak_cor$corr)

peak_cor$corr_dif <- peak_cor$gene_corr_mean - peak_cor$corr

peak_cor <-dplyr::select(dorc_by_clust_precise, put_target_genes, class) %>%
  dplyr::rename(gene=put_target_genes, dorc_class=class) %>%
  unique() %>%
  right_join(peak_cor)

ggplot(peak_cor, aes(corr_dif, fill=dorc_class, color=dorc_class)) +
  geom_density(alpha=0.2) +
  theme_classic()

ggplot(peak_cor, aes(corr, fill=dorc_class, color=dorc_class)) +
  geom_density(alpha=0.2) +
  theme_classic()

ggplot(peak_cor, aes(x= dorc_class, y=corr, fill=dorc_class)) +
  geom_boxplot(notch = T) +
  theme_classic()

ggplot(peak_cor, aes(x=corr, y=corr_dif, color=dorc_class)) +
  geom_point(alpha=0.1) +
  theme_classic() +
  facet_wrap(~dorc_class)
```

Here we see the motivation of this analysis.

1) DORCs primarily associated with redundant peaks are enriched for higher peak2peak correlations and smaller differences in gene2peak - peak2peak correlations. However, not all peaks in redundant DORCs are redundant and not all peaks in other classes are not redundant.

In fact, if we achieve this classification at the level of peaks, we can then ask per gene, what percentage of peak2peak interactions appear to be redundant.

We can incorporate the information on the peak clusters:

```{r}
peak_cor <- left_join(peak_cor, data.frame(peak_1=names(lin_clust), clust_1=lin_clust, stringsAsFactors = F)) %>%
  left_join(data.frame(peak_2=names(lin_clust), clust_2=lin_clust, stringsAsFactors = F))

ggplot(peak_cor, aes(corr, fill=as.factor(clust_1==clust_2), color=as.factor(clust_1==clust_2))) +
  geom_density(alpha=0.2) +
  theme_classic()

ggplot(peak_cor, aes(x= dorc_class, y=corr, fill=as.factor(clust_1==clust_2))) +
  geom_boxplot(notch = T) +
  theme_classic()
```

We can use our previous cutoff to identify redundant peaks across all gene classes

```{r}
quantile(peak_cor$corr, 0.1)
quantile(peak_cor$corr, 0.9)

peak_cor$redundant <- ifelse(peak_cor$corr >= 0.7 & peak_cor$clust_1== peak_cor$clust_2, yes = "redundant", no = ifelse(peak_cor$corr <= 0.3 & peak_cor$clust_1!= peak_cor$clust_2, yes = "different", no = "other"))

p <- ggplot() +
  geom_histogram(data= peak_cor, aes(corr), bins = 40, color="gray50", alpha=0.1) +
  geom_vline(xintercept = 0.3, color="mediumorchid3",  lty="dashed") +
  geom_vline(xintercept = 0.7, color="deepskyblue3", lty="dashed") +
  geom_rect(aes(xmin=min(peak_cor$corr), xmax=0.3, ymin=0, ymax=2500),fill="mediumorchid3", alpha=0.2) +
  geom_rect(aes(xmin=0.7, xmax=1, ymin=0, ymax=2500),fill="deepskyblue3", alpha=0.2) +
  xlab("Peak-peak correlation") +
  annotate(geom="text",x=0.84, y=1900, label="r > 0.7\n+ same cluster", color="black") +
  annotate(geom="text",x=0.1, y=1900, label="r < 0.3\n+ different cluster", color="black") +
  annotate(geom="text",x=0.1, y=2300, label='bold("Different")', color="black", parse=T) +
  annotate(geom="text",x=0.84, y=2300, label='bold("Redundant")', color="black", parse=T) +
  ylab("Count") +
  theme_classic()

p

pdf("~/Mouse_Cereb/Figures/009_targetGenes/Mouse_peaks_sameTarget_pairWiseCorrelations_Redundant_vs_Different_classification.pdf", width = 6, height = 4, useDingbats = F); print(p); dev.off()

table(peak_cor$redundant)

ggplot(peak_cor, aes(dorc_class, fill=redundant)) +
  geom_bar(position = "fill") +
  theme_classic()
```

Genes associated with redundant peaks (vs those associated with more than one peaks but not necessarily redundant)

```{r}
length(unique(peak_cor$gene[peak_cor$redundant=="redundant"]))
length(unique(peak_cor$gene))

WebGestaltR(enrichMethod = "ORA",
            organism = "mmusculus",
            enrichDatabase = "geneontology_Biological_Process_noRedundant",
            interestGene = unique(na.omit(gene.symbols$Mouse_ID[gene.symbols$put_target_genes %in% unique(peak_cor$gene[peak_cor$redundant=="redundant"])])),
            interestGeneType = "ensembl_gene_id",
            referenceGene = unique(na.omit(gene.symbols$Mouse_ID[gene.symbols$put_target_genes %in% unique(peak_cor$gene)])),
            referenceGeneType = "ensembl_gene_id",
            fdrMethod = "BH", sigMethod = "fdr", fdrThr = 0.05,
            outputDirectory = "~/Mouse_Cereb/009_peak2gene/dorcs/" ,projectName = 'redundantPeaks_BiologicalProcess_distal')

WebGestaltR(enrichMethod = "ORA",
            organism = "mmusculus",
            enrichDatabase = "geneontology_Biological_Process_noRedundant",
            interestGene = unique(na.omit(gene.symbols$Mouse_ID[gene.symbols$put_target_genes %in% unique(peak_cor$gene[peak_cor$redundant=="different"])])),
            interestGeneType = "ensembl_gene_id",
            referenceGene = unique(na.omit(gene.symbols$Mouse_ID[gene.symbols$put_target_genes %in% unique(peak_cor$gene)])),
            referenceGeneType = "ensembl_gene_id",
            fdrMethod = "BH", sigMethod = "fdr", fdrThr = 0.05,
            outputDirectory = "~/Mouse_Cereb/009_peak2gene/dorcs/" ,projectName = 'differentPeaks_BiologicalProcess_distal')

WebGestaltR(enrichMethod = "ORA",
            organism = "mmusculus",
            enrichDatabase = "geneontology_Molecular_Function_noRedundant",
            interestGene = unique(na.omit(gene.symbols$Mouse_ID[gene.symbols$put_target_genes %in% unique(peak_cor$gene[peak_cor$redundant=="redundant"])])),
            interestGeneType = "ensembl_gene_id",
            referenceGene = unique(na.omit(gene.symbols$Mouse_ID[gene.symbols$put_target_genes %in% unique(peak_cor$gene)])),
            referenceGeneType = "ensembl_gene_id",
            fdrMethod = "BH", sigMethod = "fdr", fdrThr = 0.05,
            outputDirectory = "~/Mouse_Cereb/009_peak2gene/dorcs/" ,projectName = 'redundantPeaks_MolecularFunction_distal')

WebGestaltR(enrichMethod = "ORA",
            organism = "mmusculus",
            enrichDatabase = "geneontology_Molecular_Function_noRedundant",
            interestGene = unique(na.omit(gene.symbols$Mouse_ID[gene.symbols$put_target_genes %in% unique(peak_cor$gene[peak_cor$redundant=="different"])])),
            interestGeneType = "ensembl_gene_id",
            referenceGene = unique(na.omit(gene.symbols$Mouse_ID[gene.symbols$put_target_genes %in% unique(peak_cor$gene)])),
            referenceGeneType = "ensembl_gene_id",
            fdrMethod = "BH", sigMethod = "fdr", fdrThr = 0.05,
            outputDirectory = "~/Mouse_Cereb/009_peak2gene/dorcs/" ,projectName = 'differentPeaks_MolecularFunction_distal')
```

```{r}
red_bp <- read_tsv("~/Mouse_Cereb/009_peak2gene/dorcs/Project_redundantPeaks_BiologicalProcess_distal/enrichment_results_redundantPeaks_BiologicalProcess_distal.txt")

red_bp$class <- "Redundant"

dif_bp <- read_tsv("~/Mouse_Cereb/009_peak2gene/dorcs/Project_differentPeaks_BiologicalProcess_distal/enrichment_results_differentPeaks_BiologicalProcess_distal.txt")

dif_bp$class <- "Different"

all_bp <- bind_rows(red_bp, dif_bp)

all_bp$class <- factor(all_bp$class, levels = c("Redundant", "Different"))

p <- ggplot(all_bp, aes(x=overlap, y=reorder(description, overlap), color = -log10(pValue)))+
  geom_point(aes(size=enrichmentRatio)) +
  scale_color_gradient(low = "yellow", high="red", name='-log'[10]~' p-value') +
  scale_size_continuous(name="Enrichment") +
  ylab("") +
  ggtitle("Biological Process") +
  xlab("Count") +
  facet_grid(class ~ ., scales = "free_y", space="free") +
  theme_bw() +
  theme(strip.text.y = element_text(angle = 0))

p

pdf("~/Mouse_Cereb/Figures/009_targetGenes/Mouse_peaks_pairwiseCor_redundantVsDifferent_targetGenes_BPenrichment.pdf", width = 7, height = 5, useDingbats = F); print(p); dev.off()
```

### Comparing to peaks assigned to the same gene but with more distinct activity (i.e. non-redundant)

We can try to investigate them a bit more by considering:
1) Spatial clustering (are they closer to each other than the average distance between adjacent distal peaks that don't belong to the same multiCRE? -> same criteria as we used to identify the redundant peaks but without asking them to have the same target gene and activity in the same cluster.

```{r}
peak_cor$dist <- sapply(1:nrow(peak_cor), function(x) {
  peak1 <- str_split(peak_cor$peak_1[x], "_", simplify = T)
  peak2 <- str_split(peak_cor$peak_2[x], "_", simplify = T)
  starts <- as.numeric(c(peak1[2], peak2[2]))
  ends <- as.numeric(c(peak1[3], peak2[3]))
  dist <- max(starts) - min(ends)
  return(dist)
})

hist(log10(peak_cor$dist), breaks = 100)

ggplot(peak_cor, aes(log10(dist), fill=redundant)) +
  geom_density(alpha=0.3) +
  theme_classic()

p <- ggplot(peak_cor, aes(log10(dist),color=redundant)) +
  geom_density(alpha=0) +
  xlab("Peak-peak distance (log10 bp)") +
  scale_color_manual(values = c("mediumorchid3", "gray80", "deepskyblue3"),  name="Peak-peak\ninteraction") +
  theme_classic()

p

pdf("~/Mouse_Cereb/Figures/009_targetGenes/Mouse_peaks_sameTarget_pairWiseCorrelations_Redundant_vs_Different_distance_noDiff.pdf", width = 5, height = 4, useDingbats = F); print(p); dev.off()


wilcox.test(peak_cor$dist[peak_cor$redundant=="redundant"], peak_cor$dist[peak_cor$redundant=="other"])
```

No difference in distance compared to other peaks targetting the same gene but not being redundant to each other.

2) Motif content similarities (are they more similar to each other in terms of TF binding compared to peaks that are targetting the same gene but are not redundant to each other)?

First, we should cluster the motifs so that we have account for motif similarity across multiple TFs (many bHLH or Homeobox TFs might recognise the same motif, which could artificially inflate the similarity for peask containing these motifs).

We use a method similar to what was done by J. Vierstra to identify similar motifs, however we cluster using TFBSTools and Pearson's correlation as a similarity metric.

```{r, eval=FALSE}
motifs.pwm <- readRDS("~/Mouse_Cereb/proj4_chromVar/Annotations/Motif_cisbp-In-Peaks-Summary.rds")

motifs.pwm <- motifs.pwm$motifList

motif.similarity <- do.call(rbind,lapply(motifs.pwm, function(m1) {
  sapply(motifs.pwm, function(m2) {
    TFBSTools::PWMSimilarity(m1, m2, method = "Pearson")
  })
}))

saveRDS(motif.similarity, "~/Mouse_Cereb/007_chromvar/Mouse_Cerebellum_chromVar_cisBP_PWM_pearson_similarity.rds")
```

```{r}
motif.similarity <- readRDS("~/Mouse_Cereb/007_chromvar/Mouse_Cerebellum_chromVar_cisBP_PWM_pearson_similarity.rds")

h_motif <- hclust(dist(motif.similarity), method = "ward.D2")

plot(log10(h_motif$height + 1e-1))
abline(h = log10(2), col="red")

summary(h_motif$height)

pheatmap::pheatmap(motif.similarity, show_rownames = F, show_colnames = F, cluster_rows = h_motif, cluster_cols = h_motif)

pheatmap::pheatmap(motif.similarity, show_rownames = F, show_colnames = F, cluster_rows = h_motif, cluster_cols = h_motif, filename = "~/Mouse_Cereb/Figures/009_targetGenes/Mouse_chromvar_cisBP_motifSimilarity_Pearson_rho.pdf", width = 4.5, height = 4)

motif_clust <- cutree(h_motif, h=2)

length(unique(motif_clust))

summary(as.numeric(table(motif_clust)))
```

```{r}
motif_ix <- readRDS("~/Mouse_Cereb/proj4_chromVar/Annotations/Motif_cisbp-Matches-In-Peaks.rds")

motif_matches <- assay(motif_ix)

row.names(motif_matches) <- paste(seqnames(motif_ix@rowRanges), start(motif_ix@rowRanges), end(motif_ix@rowRanges), sep =  "_")

motif_matches <- motif_matches[union(peak_cor$peak_1, peak_cor$peak_2), ]

motif_matches_byPeak <- lapply(1:nrow(motif_matches), function(x) colnames(motif_matches)[which(motif_matches[x,] > 0)])

names(motif_matches_byPeak) <- row.names(motif_matches)

motif_matches_byPeak[[peak_cor$peak_1[1]]]
motif_matches_byPeak[[peak_cor$peak_2[1]]]
motif_matches_byPeak[[peak_cor$peak_1[2]]]
motif_matches_byPeak[[peak_cor$peak_2[2]]]

## Now collapsing to the motif clusters
motif_clust_matches_byPeak <- lapply(1:length(motif_matches_byPeak), function(i) {
  unique(motif_clust[motif_matches_byPeak[[i]]])
})

motif_clust_matches_byPeak[[peak_cor$peak_1[1]]]
motif_clust_matches_byPeak[[peak_cor$peak_2[1]]]

intersect(motif_clust_matches_byPeak[[peak_cor$peak_1[1]]], motif_clust_matches_byPeak[[peak_cor$peak_2[1]]])

names(motif_clust_matches_byPeak) <- names(motif_matches_byPeak)

## Let's calculate a Jaccard index for the similarity of two peaks in terms of motif content
peak_cor$motif_sim_ji <- sapply(1:nrow(peak_cor), function(i) {
  ji <- length(intersect(motif_clust_matches_byPeak[[peak_cor$peak_1[i]]], motif_clust_matches_byPeak[[peak_cor$peak_2[i]]]))/length(union(motif_clust_matches_byPeak[[peak_cor$peak_1[i]]], motif_clust_matches_byPeak[[peak_cor$peak_2[i]]]))
})

peak_cor$motif_union <- sapply(1:nrow(peak_cor), function(i) {
  u <- length(union(motif_clust_matches_byPeak[[peak_cor$peak_1[i]]], motif_clust_matches_byPeak[[peak_cor$peak_2[i]]]))
})

hist(peak_cor$motif_sim_ji, breaks = 100)

ggplot(peak_cor, aes(motif_sim_ji, fill=redundant)) +
  geom_density(alpha=0.3) +
  theme_classic()

p <- ggplot(peak_cor, aes(motif_sim_ji,color=redundant)) +
  geom_density(alpha=0) +
  xlab("TF motif content (non-redundant) Jaccard similarity") +
  scale_color_manual(values = c("mediumorchid3", "gray80", "deepskyblue3"),  name="Peak-peak\ninteraction") +
  theme_classic()

p

pdf("~/Mouse_Cereb/Figures/009_targetGenes/Mouse_peaks_sameTarget_pairWiseCorrelations_Redundant_vs_Different_MotifSimilarity_noDiff.pdf", width = 5, height = 4, useDingbats = F); print(p); dev.off()

wilcox.test(peak_cor$motif_sim_ji[peak_cor$redundant=="redundant"], peak_cor$motif_sim_ji[peak_cor$redundant=="other"])

wilcox.test(peak_cor$motif_sim_ji[peak_cor$redundant=="different"], peak_cor$motif_sim_ji[peak_cor$redundant=="other"])

median(peak_cor$motif_sim_ji[peak_cor$redundant=="redundant"])
median(peak_cor$motif_sim_ji[peak_cor$redundant=="other"])
median(peak_cor$motif_sim_ji[peak_cor$redundant=="different"])

ggplot(peak_cor, aes(motif_union, fill=redundant)) +
  geom_density(alpha=0.3) +
  theme_classic()

p <- ggplot(peak_cor, aes(motif_union,color=redundant)) +
  geom_density(alpha=0) +
  xlab("Union of non-redundant TF motifs") +
  scale_color_manual(values = c("mediumorchid3", "gray80", "deepskyblue3"),  name="Peak-peak\ninteraction") +
  theme_classic()

p

pdf("~/Mouse_Cereb/Figures/009_targetGenes/Mouse_peaks_sameTarget_pairWiseCorrelations_Redundant_vs_Different_MotifUnion_Sig.pdf", width = 5, height = 4, useDingbats = F); print(p); dev.off()

wilcox.test(peak_cor$motif_union[peak_cor$redundant=="redundant"], peak_cor$motif_union[peak_cor$redundant=="other"])
wilcox.test(peak_cor$motif_union[peak_cor$redundant=="other"], peak_cor$motif_union[peak_cor$redundant=="different"])
```

3) PhastCons similarities (are they more similar to each other in terms of conservation compared to peaks that are active in the same cluster but are on different chromosomes to each other (thus not regulating the same gene))

```{r}
peak_cor$phastcons_dif <- abs(peak_cor$phastcons_1 - peak_cor$phastcons_2)
peak_cor$age_dif <- abs(peak_cor$age_1 - peak_cor$age_2)

ggplot(peak_cor, aes(phastcons_dif, fill=redundant)) +
  geom_density(alpha=0.3) +
  theme_classic()

ggplot(peak_cor, aes(x=redundant, y=phastcons_dif, fill=redundant)) +
  geom_boxplot(notch = T) +
  scale_fill_manual(values = c("mediumorchid3", "gray80", "deepskyblue3"),  name="Peak-peak\ninteraction") +
  ylab("PhastCons vertebrate difference") +
  xlab("Peak-peak interaction") +
  theme_classic()

wilcox.test(peak_cor$phastcons_dif[peak_cor$redundant=="redundant"], peak_cor$phastcons_dif[peak_cor$redundant=="other"])

wilcox.test(peak_cor$phastcons_dif[peak_cor$redundant=="redundant"], peak_cor$phastcons_dif[peak_cor$redundant=="different"])

wilcox.test(peak_cor$phastcons_dif[peak_cor$redundant=="other"], peak_cor$phastcons_dif[peak_cor$redundant=="different"])

ggplot(peak_cor, aes(age_dif, fill=redundant)) +
  geom_density(alpha=0.3) +
  theme_classic()

ggplot(peak_cor, aes(x=redundant, y=log10(age_dif), fill=redundant)) +
  geom_boxplot(notch = T) +
  theme_classic()

wilcox.test(peak_cor$age_dif[peak_cor$redundant=="redundant"], peak_cor$age_dif[peak_cor$redundant=="other"])

wilcox.test(peak_cor$age_dif[peak_cor$redundant=="redundant"], peak_cor$age_dif[peak_cor$redundant=="different"])

wilcox.test(peak_cor$age_dif[peak_cor$redundant=="other"], peak_cor$age_dif[peak_cor$redundant=="different"])
```

4) Overall phastCons conservation (are peaks participating in these redundant clusters more or less conserved compared to peaks active in the same cluster and uniquely assigned to target genes [thus controlling for expression but contrasting the presence of additional redundant peaks vs being the only peak with that activity]).

```{r}
peak_cor$phastcons_mean <- rowMeans(peak_cor[, c("phastcons_1", "phastcons_2")])
peak_cor$phastcons_glires_mean <- rowMeans(peak_cor[, c("phastcons_glires_1", "phastcons_glires_2")])
peak_cor$age_mean <- rowMeans(peak_cor[, c("age_1", "age_2")])

ggplot(peak_cor, aes(phastcons_mean, fill=redundant, color=redundant)) +
  geom_density(alpha=0.1) +
  theme_classic()

ggplot(peak_cor, aes(x=redundant, y=phastcons_mean, fill=redundant)) +
  geom_boxplot(notch = T) +
  theme_classic()

wilcox.test(peak_cor$phastcons_mean[peak_cor$redundant=="redundant"], peak_cor$phastcons_mean[peak_cor$redundant=="other"])

ggplot(peak_cor, aes(phastcons_glires_mean, fill=redundant, color=redundant)) +
  geom_density(alpha=0.1) +
  theme_classic()

ggplot(peak_cor, aes(x=redundant, y=phastcons_glires_mean, fill=redundant)) +
  geom_boxplot(notch = T) +
  theme_classic()

wilcox.test(peak_cor$phastcons_glires_mean[peak_cor$redundant=="redundant"], peak_cor$phastcons_glires_mean[peak_cor$redundant=="other"])
```

We see very mild differences here. The problem here is that we have to account for the activity pattern, as peaks active early are typically more conserved and modular peaks are enriched for early pleiotropic genes, whereas redundant peaks are enriched for late activity (less conserved).

```{r}
major_clust <- filter(peak_cor, redundant=="redundant") %>%
  group_by(clust_1) %>%
  dplyr::count() %>%
  filter(n >= 50)

ggplot(filter(peak_cor, clust_1 %in% major_clust$clust_1), aes(x=as.factor(clust_1), y=phastcons_glires_mean, fill=redundant)) +
  geom_boxplot(notch = T) +
  theme_classic()

ggplot(filter(peak_cor, clust_1 %in% major_clust$clust_1), aes(x=as.factor(clust_1), y=phastcons_mean, fill=redundant)) +
  geom_boxplot(notch = T) +
  theme_classic()

ggplot(filter(peak_cor, clust_1 %in% major_clust$clust_1), aes(x=as.factor(clust_1), y=age_mean, fill=redundant)) +
  geom_boxplot(notch = T) +
  theme_classic()
```

When accounting for the activity pattern, we see that redundant peaks are subjected to stronger constraint (as a pair) than peaks with distinct activity.

Maybe a better control is to compare with peaks active in the same cluster but uniquely assigned to a target gene.

Let's add the unique peaks to the analysis:

At this stage we are still considering peak pairs, meaning each peak can appear in several interactions.

```{r}
unique_peaks_stats <- ungroup(unique_peaks) %>%
  dplyr::select(peak, meanPhastCons_100bp,meanPhastCons_Glires_100bp ,min_age_num) %>%
  dplyr::rename(phastcons_mean=meanPhastCons_100bp, phastcons_glires_mean=meanPhastCons_Glires_100bp, age_mean=min_age_num) %>%
  left_join(data.frame(peak=names(lin_clust), clust_1=lin_clust, stringsAsFactors = F)) %>%
  mutate(redundant="unique") %>%
  bind_rows(peak_cor) %>%
  mutate(redundant=factor(redundant, levels = c("unique", "different", "other", "redundant")))

ggplot(filter(unique_peaks_stats, clust_1 %in% major_clust$clust_1), aes(x=as.factor(clust_1), y=phastcons_mean, fill=redundant)) +
  geom_boxplot(notch = T) +
  theme_classic()

ggplot(filter(unique_peaks_stats, clust_1 %in% major_clust$clust_1), aes(x=as.factor(clust_1), y=phastcons_glires_mean, fill=redundant)) +
  geom_boxplot(notch = T)+
  theme_classic()

ggplot(filter(unique_peaks_stats, clust_1 %in% major_clust$clust_1), aes(x=as.factor(clust_1), y=age_mean, fill=redundant)) +
  geom_boxplot(notch = T)+
  theme_classic()
```

Only counting each peak once to account for inflation of multipeak signal due to presence in multiple pairs. This means we will classify each peak into a single label (redundant, different, unique)

```{r}
red_peaks <- union(peak_cor$peak_1[peak_cor$redundant=="redundant"],peak_cor$peak_2[peak_cor$redundant=="redundant"])
dif_peaks <- union(peak_cor$peak_1[peak_cor$redundant=="different"],peak_cor$peak_2[peak_cor$redundant=="different"])

length(red_peaks)
length(dif_peaks)
length(intersect(red_peaks, dif_peaks))

## The intersection should be included in the redundant peaks, as these peaks have at least one redundant partner. This leaves us with peaks that only have different interactions, as well as unique peaks as controls.

mouse_peaks_clust <- left_join(mouse_peaks, data.frame(peak=names(lin_clust), peak_clust=lin_clust, stringsAsFactors = F)) %>%
  filter(peak %in% c(red_peaks, dif_peaks, unique_peaks$peak))

mouse_peaks_clust$class <- factor(sapply(1:nrow(mouse_peaks_clust), function(i) ifelse(mouse_peaks_clust$peak[i] %in% unique_peaks$peak, yes = "unique", no = ifelse(mouse_peaks_clust$peak[i] %in% red_peaks, yes = "redundant", no = ifelse(mouse_peaks_clust$peak[i] %in% dif_peaks, yes = "different", no = "other")))), levels = c("unique", "different", "redundant"))
table(mouse_peaks_clust$class)

maj_clust <- filter(mouse_peaks_clust, class=="redundant") %>%
  group_by(peak_clust) %>%
  dplyr::count() %>%
  filter(n >= 50)

p <- ggplot(filter(mouse_peaks_clust, peak_clust %in% maj_clust$peak_clust), aes(x=as.factor(peak_clust), y=meanPhastCons_100bp, fill=class)) +
  geom_boxplot(notch = T) +
  ylab("PhastCons vertebrates") +
  xlab("Peak activity cluster") +
  scale_fill_manual(values = c("darkolivegreen3","mediumorchid3", "deepskyblue3"), name="Peak\ninteraction\nclass") +
  theme_classic()

p 

pdf("~/Mouse_Cereb/Figures/009_targetGenes/Mouse_peaks_sameTarget_pairWiseCorrelations_Redundant_vs_Different_vs_unique_phastCons_sig.pdf", width = 6, height = 4, useDingbats = F); print(p); dev.off()

p <- ggplot(filter(mouse_peaks_clust, peak_clust %in% maj_clust$peak_clust), aes(x=as.factor(peak_clust), y=meanPhastCons_Glires_100bp, fill=class)) +
  geom_boxplot(notch = T) +
  ylab("PhastCons glires") +
  xlab("Peak activity cluster") +
  scale_fill_manual(values = c("darkolivegreen3","mediumorchid3", "deepskyblue3"), name="Peak\ninteraction\nclass") +
  theme_classic()

p 

pdf("~/Mouse_Cereb/Figures/009_targetGenes/Mouse_peaks_sameTarget_pairWiseCorrelations_Redundant_vs_Different_vs_unique_phastCons_glires_sig.pdf", width = 6, height = 4, useDingbats = F); print(p); dev.off()

ggplot(filter(mouse_peaks_clust, peak_clust %in% maj_clust$peak_clust), aes(x=as.factor(peak_clust), y=min_age_num, fill=class)) +
  geom_boxplot(notch = T) +
  theme_classic()

## Stats for phastcons in vertebrates
wilcox.test(mouse_peaks_clust$meanPhastCons_100bp[mouse_peaks_clust$class=="redundant" & mouse_peaks_clust$peak_clust==3], mouse_peaks_clust$meanPhastCons_100bp[mouse_peaks_clust$class=="different" & mouse_peaks_clust$peak_clust==3])

wilcox.test(mouse_peaks_clust$meanPhastCons_100bp[mouse_peaks_clust$class=="redundant" & mouse_peaks_clust$peak_clust==3], mouse_peaks_clust$meanPhastCons_100bp[mouse_peaks_clust$class=="unique" & mouse_peaks_clust$peak_clust==3])

wilcox.test(mouse_peaks_clust$meanPhastCons_100bp[mouse_peaks_clust$class=="redundant" & mouse_peaks_clust$peak_clust==6], mouse_peaks_clust$meanPhastCons_100bp[mouse_peaks_clust$class=="different" & mouse_peaks_clust$peak_clust==6])

wilcox.test(mouse_peaks_clust$meanPhastCons_100bp[mouse_peaks_clust$class=="redundant" & mouse_peaks_clust$peak_clust==6], mouse_peaks_clust$meanPhastCons_100bp[mouse_peaks_clust$class=="unique" & mouse_peaks_clust$peak_clust==6])

wilcox.test(mouse_peaks_clust$meanPhastCons_100bp[mouse_peaks_clust$class=="redundant" & mouse_peaks_clust$peak_clust==8], mouse_peaks_clust$meanPhastCons_100bp[mouse_peaks_clust$class=="different" & mouse_peaks_clust$peak_clust==8])

wilcox.test(mouse_peaks_clust$meanPhastCons_100bp[mouse_peaks_clust$class=="redundant" & mouse_peaks_clust$peak_clust==8], mouse_peaks_clust$meanPhastCons_100bp[mouse_peaks_clust$class=="unique" & mouse_peaks_clust$peak_clust==8])

wilcox.test(mouse_peaks_clust$meanPhastCons_100bp[mouse_peaks_clust$class=="redundant" & mouse_peaks_clust$peak_clust==16], mouse_peaks_clust$meanPhastCons_100bp[mouse_peaks_clust$class=="different" & mouse_peaks_clust$peak_clust==16])

wilcox.test(mouse_peaks_clust$meanPhastCons_100bp[mouse_peaks_clust$class=="redundant" & mouse_peaks_clust$peak_clust==16], mouse_peaks_clust$meanPhastCons_100bp[mouse_peaks_clust$class=="unique" & mouse_peaks_clust$peak_clust==16])

wilcox.test(mouse_peaks_clust$meanPhastCons_100bp[mouse_peaks_clust$class=="redundant" & mouse_peaks_clust$peak_clust==20], mouse_peaks_clust$meanPhastCons_100bp[mouse_peaks_clust$class=="unique" & mouse_peaks_clust$peak_clust==20])

wilcox.test(mouse_peaks_clust$meanPhastCons_100bp[mouse_peaks_clust$class=="redundant" & mouse_peaks_clust$peak_clust==20], mouse_peaks_clust$meanPhastCons_100bp[mouse_peaks_clust$class=="different" & mouse_peaks_clust$peak_clust==20])

## Stats for phastcons in glires
wilcox.test(mouse_peaks_clust$meanPhastCons_Glires_100bp[mouse_peaks_clust$class=="redundant" & mouse_peaks_clust$peak_clust==3], mouse_peaks_clust$meanPhastCons_Glires_100bp[mouse_peaks_clust$class=="different" & mouse_peaks_clust$peak_clust==3])

wilcox.test(mouse_peaks_clust$meanPhastCons_Glires_100bp[mouse_peaks_clust$class=="redundant" & mouse_peaks_clust$peak_clust==3], mouse_peaks_clust$meanPhastCons_Glires_100bp[mouse_peaks_clust$class=="unique" & mouse_peaks_clust$peak_clust==3])

wilcox.test(mouse_peaks_clust$meanPhastCons_Glires_100bp[mouse_peaks_clust$class=="redundant" & mouse_peaks_clust$peak_clust==6], mouse_peaks_clust$meanPhastCons_Glires_100bp[mouse_peaks_clust$class=="different" & mouse_peaks_clust$peak_clust==6])

wilcox.test(mouse_peaks_clust$meanPhastCons_Glires_100bp[mouse_peaks_clust$class=="redundant" & mouse_peaks_clust$peak_clust==6], mouse_peaks_clust$meanPhastCons_Glires_100bp[mouse_peaks_clust$class=="unique" & mouse_peaks_clust$peak_clust==6])

wilcox.test(mouse_peaks_clust$meanPhastCons_Glires_100bp[mouse_peaks_clust$class=="redundant" & mouse_peaks_clust$peak_clust==8], mouse_peaks_clust$meanPhastCons_Glires_100bp[mouse_peaks_clust$class=="different" & mouse_peaks_clust$peak_clust==8])

wilcox.test(mouse_peaks_clust$meanPhastCons_Glires_100bp[mouse_peaks_clust$class=="redundant" & mouse_peaks_clust$peak_clust==8], mouse_peaks_clust$meanPhastCons_Glires_100bp[mouse_peaks_clust$class=="unique" & mouse_peaks_clust$peak_clust==8])

wilcox.test(mouse_peaks_clust$meanPhastCons_Glires_100bp[mouse_peaks_clust$class=="redundant" & mouse_peaks_clust$peak_clust==16], mouse_peaks_clust$meanPhastCons_Glires_100bp[mouse_peaks_clust$class=="different" & mouse_peaks_clust$peak_clust==16])

wilcox.test(mouse_peaks_clust$meanPhastCons_Glires_100bp[mouse_peaks_clust$class=="redundant" & mouse_peaks_clust$peak_clust==16], mouse_peaks_clust$meanPhastCons_Glires_100bp[mouse_peaks_clust$class=="unique" & mouse_peaks_clust$peak_clust==16])

wilcox.test(mouse_peaks_clust$meanPhastCons_Glires_100bp[mouse_peaks_clust$class=="redundant" & mouse_peaks_clust$peak_clust==20], mouse_peaks_clust$meanPhastCons_Glires_100bp[mouse_peaks_clust$class=="unique" & mouse_peaks_clust$peak_clust==20])

wilcox.test(mouse_peaks_clust$meanPhastCons_Glires_100bp[mouse_peaks_clust$class=="redundant" & mouse_peaks_clust$peak_clust==20], mouse_peaks_clust$meanPhastCons_Glires_100bp[mouse_peaks_clust$class=="different" & mouse_peaks_clust$peak_clust==20])
```

The differences are small and our relatively small numbers don't allow for very robust statistics.

However, we see that when accounting for the activity pattern of the peak, redundant peak pairs are on average more constrained than those with different activity. All these peak pairs are still more constrained than peaks that uniquely target a gene.

These differences are much more pronounced for peaks active in development (ex. clusters 3,6,8,16) and almost absent in mature cells (20: mature GCs/UBCs).

Let's have a look into motif similarity again. What we will do here is sample 10,000 distal peak pairs from the same cluster (activity) but different chromosome (thus by definition different target gene). The we can compare the degree of similarity in motifs (and phastcons) compared to peak pairs regulating the same target gene.

```{r}
peak_cor$chr_1 <- gsub("_.*", "", peak_cor$peak_1)
peak_cor$chr_2 <- gsub("_.*", "", peak_cor$peak_2)

N_trials <- 10000
shuffled_pairs <- Reduce(bind_rows,lapply(1:N_trials, function(i) {
  set.seed(i)
  peak1 <- sample(peak_cor$peak_1, 1)
  if(sum(peak_cor$clust_1==unique(peak_cor$clust_1[peak_cor$peak_1==peak1]) & peak_cor$chr_1!=unique(peak_cor$chr_1[peak_cor$peak_1==peak1])) > 1) {
    peak2 <- sample(peak_cor$peak_1[peak_cor$clust_1==unique(peak_cor$clust_1[peak_cor$peak_1==peak1]) & peak_cor$chr_1!=unique(peak_cor$chr_1[peak_cor$peak_1==peak1])], 1)
  ji <- length(intersect(motif_clust_matches_byPeak[[peak1]], motif_clust_matches_byPeak[[peak2]]))/length(union(motif_clust_matches_byPeak[[peak1]], motif_clust_matches_byPeak[[peak2]]))
  phastcons_dif <- abs(mouse_peaks$meanPhastCons_100bp[mouse_peaks$peak==peak1] - mouse_peaks$meanPhastCons_100bp[mouse_peaks$peak==peak2])
  return(data.frame(peak_1=peak1, peak_2=peak2, motif_sim_ji=ji, peak_clust=unique(peak_cor$clust_1[peak_cor$peak_1==peak1]), phastcons_dif, stringsAsFactors = F))
  } else {
    return(NULL)
  }
}))

nrow(unique(shuffled_pairs))

shuffled_pairs <- unique(shuffled_pairs)

wilcox.test(peak_cor$phastcons_dif, shuffled_pairs$phastcons_dif)
wilcox.test(peak_cor$motif_sim_ji, shuffled_pairs$motif_sim_ji)

shuffled_pairs$redundant <- "shuffled"

pairs_all <- bind_rows(shuffled_pairs, peak_cor)

pairs_all$redundant <- factor(pairs_all$redundant, levels = c("shuffled", "different", "other", "redundant"))

ggplot(pairs_all, aes(phastcons_dif, fill=redundant, color=redundant)) +
  geom_density(alpha=0.1)+
  theme_classic()

p <- ggplot(pairs_all, aes(x= redundant, y=phastcons_dif, fill=redundant)) +
  geom_boxplot(notch = T) +
  scale_fill_manual(values = c("chocolate2","mediumorchid3", "gray80", "deepskyblue3"),  guide=F) +
  ylab("PhastCons vertebrate difference")+
  xlab("Peak-peak interaction") +
  theme_classic() +
  theme(axis.text.x = element_text(angle=45, hjust = 0.95))

p

pdf("~/Mouse_Cereb/Figures/009_targetGenes/Mouse_peaks_sameTarget_pairWiseCorrelations_Redundant_vs_Different_vs_shuffled_phastcons_dif_sig.pdf", width = 2.5, height = 4, useDingbats = F); print(p); dev.off()

ggplot(pairs_all, aes(log10(motif_sim_ji+1e-1), fill=redundant, color=redundant)) +
  geom_density(alpha=0.1) +
  theme_classic()

p <- ggplot(pairs_all, aes(x=redundant , y=log10(motif_sim_ji+1e-1), fill=redundant)) +
  geom_boxplot(notch = T) +
  scale_fill_manual(values = c("chocolate2","mediumorchid3", "gray80", "deepskyblue3"),  guide=F) +
  ylab("TF motif content Jaccard similarity (log10)")+
  xlab("Peak-peak interaction") +
  theme_classic() +
  theme(axis.text.x = element_text(angle=45, hjust = 0.95))

p

pdf("~/Mouse_Cereb/Figures/009_targetGenes/Mouse_peaks_sameTarget_pairWiseCorrelations_Redundant_vs_Different_vs_shuffled_motifSim_noDif.pdf", width = 2.5, height = 4, useDingbats = F); print(p); dev.off()

wilcox.test(pairs_all$phastcons_dif[pairs_all$redundant=="redundant"], pairs_all$phastcons_dif[pairs_all$redundant=="other"])
wilcox.test(pairs_all$phastcons_dif[pairs_all$redundant=="redundant"], pairs_all$phastcons_dif[pairs_all$redundant=="different"])
wilcox.test(pairs_all$phastcons_dif[pairs_all$redundant=="other"], pairs_all$phastcons_dif[pairs_all$redundant=="different"])
wilcox.test(pairs_all$phastcons_dif[pairs_all$redundant=="shuffled"], pairs_all$phastcons_dif[pairs_all$redundant=="different"])

wilcox.test(pairs_all$motif_sim_ji[pairs_all$redundant=="redundant"], pairs_all$motif_sim_ji[pairs_all$redundant=="other"])
wilcox.test(pairs_all$motif_sim_ji[pairs_all$redundant=="redundant"], pairs_all$motif_sim_ji[pairs_all$redundant=="different"])
wilcox.test(pairs_all$motif_sim_ji[pairs_all$redundant=="other"], pairs_all$motif_sim_ji[pairs_all$redundant=="different"])
wilcox.test(pairs_all$motif_sim_ji[pairs_all$redundant=="shuffled"], pairs_all$motif_sim_ji[pairs_all$redundant=="different"])
```

Comparing to shuffled pairs, where we keep the same peak cluster (activity pattern) but ask the peaks to come from different chromosomes (different target gene), we see that redundant peaks are on average more similar in terms of conservation but not motif content compared to other peaks active in the same cell type.

What about the activity patterns of redundant peaks?

```{r}
ggplot(peak_cor, aes(as.factor(clust_1), fill=redundant)) +
  geom_bar(position = "fill")

ggplot(unique_peaks_stats, aes(as.factor(clust_1), fill=redundant)) +
  geom_bar(position = "fill")

ggplot(peak_cor, aes(as.factor(clust_2), fill=redundant)) +
  geom_bar(position = "fill")
```

They are mostly enriched for clusters associated with cell fate commitment (1: isthmic/glutDN; 8: early astroglia), differentiation (3: GCs, 6: astroglia, 16: PCs) and mature neurons (20: GCs/UBCs).

This probably suggests that our power to detect such cases largely depends on cell numbers (early neurons, differentiating PCs and GC, mature GCs).

Let's take another take on genes associated with redundant vs modular peaks.

```{r}
multipeak_gene_stats <- group_by(peak_cor, gene) %>%
  summarise(nPeak=n_distinct(c(peak_1, peak_2)),
            nRedundant=n_distinct(c(peak_1[redundant=="redundant"], peak_2[redundant=="redundant"])),
            nModular=n_distinct(c(peak_1[redundant=="different"], peak_2[redundant=="different"]))
            ) %>%
  mutate(fRedundant=nRedundant/nPeak, 
         fModular=nModular/nPeak)

## Comparing with our previous stats
mean(multipeak_gene_stats$fRedundant[multipeak_gene_stats$gene %in% dorc_by_clust_precise$put_target_genes[dorc_by_clust_precise$class=="redundant"]])

mean(multipeak_gene_stats$fRedundant[multipeak_gene_stats$gene %in% dorc_by_clust_precise$put_target_genes[dorc_by_clust_precise$class=="modular"]])

mean(multipeak_gene_stats$fRedundant[multipeak_gene_stats$gene %in% dorc_by_clust_precise$put_target_genes[dorc_by_clust_precise$class=="other"]])

mean(multipeak_gene_stats$fModular[multipeak_gene_stats$gene %in% dorc_by_clust_precise$put_target_genes[dorc_by_clust_precise$class=="redundant"]])

mean(multipeak_gene_stats$fModular[multipeak_gene_stats$gene %in% dorc_by_clust_precise$put_target_genes[dorc_by_clust_precise$class=="modular"]])

mean(multipeak_gene_stats$fModular[multipeak_gene_stats$gene %in% dorc_by_clust_precise$put_target_genes[dorc_by_clust_precise$class=="other"]])
```

Overall, we see very small differences (at least with the current set of quite strict controls).

The conclusions from this analysis:

1) Genes associated with multiple peaks: development, gliogenesis, synapse formation, ion transport.
Profiling their activity by aggregating profiles of associated peaks -> major distinction in clusters associated with these functions. But unlike peaks, we mostly see activity shared across multiple cell types.

2) Modular vs redundant contribution (assessed at the gene level using residuals and fraction in top clust, i.e. looking for genes where the expression is similar to any/most of the associated peaks):
Genes primarily associated with redundant peaks have restricted expression (mature neurons, gliogenesis) and higher tau in the evodevo.
Genes with modular expression show broader activity across cell types and are active earlier in development.

3) Focusing on individual peak pairs: different or redundant activity (based on correlation in pseudocells and presence in the same global CRE cluster).
- Redundant peaks are not closer to each other than those showing different activity.
- They also don't show higher motif similarity (JI of motifs, accounting for PWM similarities) (not even more similar to shuffled peaks with the same activity [cluster] but on different chromosome [different target gene]).
-> meaning, even if they are very similar in terms of activity, they don't seem to be bound by the same TFs, and thus are likely not truely redundant (although difficult to assess solely based on motif info).
- But they are more similar in terms of age and constraint!
- Overall, when accounting for difference in activity patterns, redundant peaks are on average more constrained than those differing in activity (especially when showing activity during development and differentiation).
- Peaks that are uniquely associated to a target gene are overall less conserved than all peak pairs (even those showing different activity), even when accounting for activity patterns. Again, the differences are more pronounced for peaks active during development.

Let's export some data

```{r}
## DORCs
write_tsv(dorc_by_clust_precise, "~/Mouse_Cereb/009_peak2gene/dorcs/Mouse_Cerebellum_DORCs_5_distal_peaks_genes.txt")

write_tsv(dorc_peaks, "~/Mouse_Cereb/009_peak2gene/dorcs/Mouse_Cerebellum_DORCs_5_distal_peaks_peaks.txt")

write_tsv(modular, "~/Mouse_Cereb/009_peak2gene/dorcs/Mouse_Cerebellum_DORCs_5_distal_peaks_genes_Modular.txt")

write_tsv(redundant, "~/Mouse_Cereb/009_peak2gene/dorcs/Mouse_Cerebellum_DORCs_5_distal_peaks_genes_Redundant.txt")

write.table(dorc_activity, "~/Mouse_Cereb/009_peak2gene/dorcs/Mouse_Cerebellum_DORCs_5_distal_peaks_genes_activity_meanCPM.txt", col.names = T, row.names = T, sep="\t", quote = F)

write.table(dorc_activity.std, "~/Mouse_Cereb/009_peak2gene/dorcs/Mouse_Cerebellum_DORCs_5_distal_peaks_genes_activity_meanCPM_std.txt", col.names = T, row.names = T, sep="\t", quote = F)

## Peak pairs
write_tsv(peak_cor, "~/Mouse_Cereb/009_peak2gene/dorcs/Mouse_Cerebellum_distal_peak_redundancy_pairwiseCorrelations.txt")

write_tsv(unique_peaks_stats, "~/Mouse_Cereb/009_peak2gene/dorcs/Mouse_Cerebellum_uniquePeaks.txt")

write_tsv(mouse_peaks_clust, "~/Mouse_Cereb/009_peak2gene/dorcs/Mouse_Cerebellum_peak_redundancy_classification.txt")

write_tsv(pairs_all, "~/Mouse_Cereb/009_peak2gene/dorcs/Mouse_Cerebellum_multiPeak_vs_shuffledActivityMatched.txt")

```

```{r}
sessionInfo()
```

